export class Node{constructor(t){this.incoming=new Map,this.outgoing=new Map,this.data=t}}export class Graph{constructor(t){this._hashFn=t,this._nodes=new Map}roots(){const t=[];for(let o of this._nodes.values())0===o.outgoing.size&&t.push(o);return t}insertEdge(t,o){const e=this.lookupOrInsertNode(t),n=this.lookupOrInsertNode(o);e.outgoing.set(this._hashFn(o),n),n.incoming.set(this._hashFn(t),e)}removeNode(t){const o=this._hashFn(t);this._nodes.delete(o);for(let e of this._nodes.values())e.outgoing.delete(o),e.incoming.delete(o)}lookupOrInsertNode(t){const o=this._hashFn(t);let e=this._nodes.get(o);return e||(e=new Node(t),this._nodes.set(o,e)),e}isEmpty(){return 0===this._nodes.size}toString(){let t=[];for(let[o,e]of this._nodes)t.push(`${o}, (incoming)[${[...e.incoming.keys()].join(", ")}], (outgoing)[${[...e.outgoing.keys()].join(",")}]`);return t.join("\n")}findCycleSlow(){for(let[t,o]of this._nodes){const e=new Set([t]),n=this._findCycle(o,e);if(n)return n}}_findCycle(t,o){for(let[e,n]of t.outgoing){if(o.has(e))return[...o,e].join(" -> ");o.add(e);const t=this._findCycle(n,o);if(t)return t;o.delete(e)}}}