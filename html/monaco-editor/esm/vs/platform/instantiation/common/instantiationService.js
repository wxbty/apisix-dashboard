import{IdleValue}from"../../../base/common/async.js";import{illegalState}from"../../../base/common/errors.js";import{SyncDescriptor}from"./descriptors.js";import{Graph}from"./graph.js";import{IInstantiationService,_util}from"./instantiation.js";import{ServiceCollection}from"./serviceCollection.js";const _enableTracing=!1;class CyclicDependencyError extends Error{constructor(e){var t;super("cyclic dependency between services"),this.message=null!==(t=e.findCycleSlow())&&void 0!==t?t:`UNABLE to detect cycle, dumping graph: \n${e.toString()}`}}export class InstantiationService{constructor(e=new ServiceCollection,t=!1,n){this._activeInstantiations=new Set,this._services=e,this._strict=t,this._parent=n,this._services.set(IInstantiationService,this)}createChild(e){return new InstantiationService(e,this._strict,this)}invokeFunction(e,...t){let n=Trace.traceInvocation(e),r=!1;try{const i={get:e=>{if(r)throw illegalState("service accessor is only valid during the invocation of its target method");const t=this._getOrCreateServiceInstance(e,n);if(!t)throw new Error(`[invokeFunction] unknown service '${e}'`);return t}};return e(i,...t)}finally{r=!0,n.stop()}}createInstance(e,...t){let n,r;return e instanceof SyncDescriptor?(n=Trace.traceCreation(e.ctor),r=this._createInstance(e.ctor,e.staticArguments.concat(t),n)):(n=Trace.traceCreation(e),r=this._createInstance(e,t,n)),n.stop(),r}_createInstance(e,t=[],n){let r=_util.getServiceDependencies(e).sort(((e,t)=>e.index-t.index)),i=[];for(const c of r){let t=this._getOrCreateServiceInstance(c.id,n);if(!t&&this._strict&&!c.optional)throw new Error(`[createInstance] ${e.name} depends on UNKNOWN service ${c.id}.`);i.push(t)}let s=r.length>0?r[0].index:t.length;if(t.length!==s){console.warn(`[createInstance] First service dependency of ${e.name} at position ${s+1} conflicts with ${t.length} static arguments`);let n=s-t.length;t=n>0?t.concat(new Array(n)):t.slice(0,s)}return new e(...[...t,...i])}_setServiceInstance(e,t){if(this._services.get(e)instanceof SyncDescriptor)this._services.set(e,t);else{if(!this._parent)throw new Error("illegalState - setting UNKNOWN service instance");this._parent._setServiceInstance(e,t)}}_getServiceInstanceOrDescriptor(e){let t=this._services.get(e);return!t&&this._parent?this._parent._getServiceInstanceOrDescriptor(e):t}_getOrCreateServiceInstance(e,t){let n=this._getServiceInstanceOrDescriptor(e);return n instanceof SyncDescriptor?this._safeCreateAndCacheServiceInstance(e,n,t.branch(e,!0)):(t.branch(e,!1),n)}_safeCreateAndCacheServiceInstance(e,t,n){if(this._activeInstantiations.has(e))throw new Error(`illegal state - RECURSIVELY instantiating service '${e}'`);this._activeInstantiations.add(e);try{return this._createAndCacheServiceInstance(e,t,n)}finally{this._activeInstantiations.delete(e)}}_createAndCacheServiceInstance(e,t,n){const r=new Graph((e=>e.id.toString()));let i=0;const s=[{id:e,desc:t,_trace:n}];while(s.length){const t=s.pop();if(r.lookupOrInsertNode(t),i++>1e3)throw new CyclicDependencyError(r);for(let n of _util.getServiceDependencies(t.desc.ctor)){let i=this._getServiceInstanceOrDescriptor(n.id);if(i||n.optional||console.warn(`[createInstance] ${e} depends on ${n.id} which is NOT registered.`),i instanceof SyncDescriptor){const e={id:n.id,desc:i,_trace:t._trace.branch(n.id,!0)};r.insertEdge(t,e),s.push(e)}}}while(1){const e=r.roots();if(0===e.length){if(!r.isEmpty())throw new CyclicDependencyError(r);break}for(const{data:t}of e){const e=this._getServiceInstanceOrDescriptor(t.id);if(e instanceof SyncDescriptor){const e=this._createServiceInstanceWithOwner(t.id,t.desc.ctor,t.desc.staticArguments,t.desc.supportsDelayedInstantiation,t._trace);this._setServiceInstance(t.id,e)}r.removeNode(t)}}return this._getServiceInstanceOrDescriptor(e)}_createServiceInstanceWithOwner(e,t,n=[],r,i){if(this._services.get(e)instanceof SyncDescriptor)return this._createServiceInstance(t,n,r,i);if(this._parent)return this._parent._createServiceInstanceWithOwner(e,t,n,r,i);throw new Error(`illegalState - creating UNKNOWN service instance ${t.name}`)}_createServiceInstance(e,t=[],n,r){if(n){const n=new IdleValue((()=>this._createInstance(e,t,r)));return new Proxy(Object.create(null),{get(e,t){if(t in e)return e[t];let r=n.value,i=r[t];return"function"!==typeof i||(i=i.bind(r),e[t]=i),i},set(e,t,r){return n.value[t]=r,!0}})}return this._createInstance(e,t,r)}}export class Trace{constructor(e,t){this.type=e,this.name=t,this._start=Date.now(),this._dep=[]}static traceInvocation(e){return _enableTracing?new Trace(1,e.name||e.toString().substring(0,42).replace(/\n/g,"")):Trace._None}static traceCreation(e){return _enableTracing?new Trace(0,e.name):Trace._None}branch(e,t){let n=new Trace(2,e.toString());return this._dep.push([e,t,n]),n}stop(){let e=Date.now()-this._start;Trace._totals+=e;let t=!1;function n(e,r){let i=[],s=new Array(e+1).join("\t");for(const[c,a,o]of r._dep)if(a&&o){t=!0,i.push(`${s}CREATES -> ${c}`);let r=n(e+1,o);r&&i.push(r)}else i.push(`${s}uses -> ${c}`);return i.join("\n")}let r=[`${0===this.type?"CREATE":"CALL"} ${this.name}`,`${n(1,this)}`,`DONE, took ${e.toFixed(2)}ms (grand total ${Trace._totals.toFixed(2)}ms)`];(e>2||t)&&console.log(r.join("\n"))}}Trace._None=new class extends Trace{constructor(){super(-1,null)}stop(){}branch(){return this}},Trace._totals=0;