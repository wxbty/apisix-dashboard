import{IntervalTimer,TimeoutTimer}from"../../../base/common/async.js";import{Emitter,Event}from"../../../base/common/event.js";import{Disposable}from"../../../base/common/lifecycle.js";import*as nls from"../../../nls.js";const HIGH_FREQ_COMMANDS=/^(cursor|delete)/;export class AbstractKeybindingService extends Disposable{constructor(e,i,t,r,n){super(),this._contextKeyService=e,this._commandService=i,this._telemetryService=t,this._notificationService=r,this._logService=n,this._onDidUpdateKeybindings=this._register(new Emitter),this._currentChord=null,this._currentChordChecker=new IntervalTimer,this._currentChordStatusMessage=null,this._ignoreSingleModifiers=KeybindingModifierSet.EMPTY,this._currentSingleModifier=null,this._currentSingleModifierClearTimeout=new TimeoutTimer,this._logging=!1}get onDidUpdateKeybindings(){return this._onDidUpdateKeybindings?this._onDidUpdateKeybindings.event:Event.None}dispose(){super.dispose()}_log(e){this._logging&&this._logService.info(`[KeybindingService]: ${e}`)}getKeybindings(){return this._getResolver().getKeybindings()}lookupKeybinding(e,i){const t=this._getResolver().lookupPrimaryKeybinding(e,i||this._contextKeyService);if(t)return t.resolvedKeybinding}dispatchEvent(e,i){return this._dispatch(e,i)}softDispatch(e,i){const t=this.resolveKeyboardEvent(e);if(t.isChord())return console.warn("Unexpected keyboard event mapped to a chord"),null;const[r]=t.getDispatchParts();if(null===r)return null;const n=this._contextKeyService.getContext(i),s=this._currentChord?this._currentChord.keypress:null;return this._getResolver().resolve(n,s,r)}_enterChordMode(e,i){this._currentChord={keypress:e,label:i},this._currentChordStatusMessage=this._notificationService.status(nls.localize("first.chord","({0}) was pressed. Waiting for second key of chord...",i));const t=Date.now();this._currentChordChecker.cancelAndSet((()=>{this._documentHasFocus()?Date.now()-t>5e3&&this._leaveChordMode():this._leaveChordMode()}),500)}_leaveChordMode(){this._currentChordStatusMessage&&(this._currentChordStatusMessage.dispose(),this._currentChordStatusMessage=null),this._currentChordChecker.cancel(),this._currentChord=null}_dispatch(e,i){return this._doDispatch(this.resolveKeyboardEvent(e),i,!1)}_singleModifierDispatch(e,i){const t=this.resolveKeyboardEvent(e),[r]=t.getSingleModifierDispatchParts();if(r)return this._ignoreSingleModifiers.has(r)?(this._log(`+ Ignoring single modifier ${r} due to it being pressed together with other keys.`),this._ignoreSingleModifiers=KeybindingModifierSet.EMPTY,this._currentSingleModifierClearTimeout.cancel(),this._currentSingleModifier=null,!1):(this._ignoreSingleModifiers=KeybindingModifierSet.EMPTY,null===this._currentSingleModifier?(this._log(`+ Storing single modifier for possible chord ${r}.`),this._currentSingleModifier=r,this._currentSingleModifierClearTimeout.cancelAndSet((()=>{this._log("+ Clearing single modifier due to 300ms elapsed."),this._currentSingleModifier=null}),300),!1):r===this._currentSingleModifier?(this._log(`/ Dispatching single modifier chord ${r} ${r}`),this._currentSingleModifierClearTimeout.cancel(),this._currentSingleModifier=null,this._doDispatch(t,i,!0)):(this._log(`+ Clearing single modifier due to modifier mismatch: ${this._currentSingleModifier} ${r}`),this._currentSingleModifierClearTimeout.cancel(),this._currentSingleModifier=null,!1));const[n]=t.getParts();return this._ignoreSingleModifiers=new KeybindingModifierSet(n),null!==this._currentSingleModifier&&this._log("+ Clearing single modifier due to other key up."),this._currentSingleModifierClearTimeout.cancel(),this._currentSingleModifier=null,!1}_doDispatch(e,i,t=!1){let r=!1;if(e.isChord())return console.warn("Unexpected keyboard event mapped to a chord"),!1;let n=null,s=null;if(t){const[i]=e.getSingleModifierDispatchParts();n=i,s=i}else[n]=e.getDispatchParts(),s=this._currentChord?this._currentChord.keypress:null;if(null===n)return this._log("\\ Keyboard event cannot be dispatched in keydown phase."),r;const o=this._contextKeyService.getContext(i),d=e.getLabel(),c=this._getResolver().resolve(o,s,n);return this._logService.trace("KeybindingService#dispatch",d,null===c||void 0===c?void 0:c.commandId),c&&c.enterChord?(r=!0,this._enterChordMode(n,d),r):(this._currentChord&&(c&&c.commandId||(this._notificationService.status(nls.localize("missing.chord","The key combination ({0}, {1}) is not a command.",this._currentChord.label,d),{hideAfter:1e4}),r=!0)),this._leaveChordMode(),c&&c.commandId&&(c.bubble||(r=!0),"undefined"===typeof c.commandArgs?this._commandService.executeCommand(c.commandId).then(void 0,(e=>this._notificationService.warn(e))):this._commandService.executeCommand(c.commandId,c.commandArgs).then(void 0,(e=>this._notificationService.warn(e))),HIGH_FREQ_COMMANDS.test(c.commandId)||this._telemetryService.publicLog2("workbenchActionExecuted",{id:c.commandId,from:"keybinding"})),r)}mightProducePrintableCharacter(e){return!e.ctrlKey&&!e.metaKey&&(e.keyCode>=31&&e.keyCode<=56||e.keyCode>=21&&e.keyCode<=30)}}class KeybindingModifierSet{constructor(e){this._ctrlKey=!!e&&e.ctrlKey,this._shiftKey=!!e&&e.shiftKey,this._altKey=!!e&&e.altKey,this._metaKey=!!e&&e.metaKey}has(e){switch(e){case"ctrl":return this._ctrlKey;case"shift":return this._shiftKey;case"alt":return this._altKey;case"meta":return this._metaKey}}}KeybindingModifierSet.EMPTY=new KeybindingModifierSet(null);