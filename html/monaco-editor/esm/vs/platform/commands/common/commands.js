import{Emitter}from"../../../base/common/event.js";import{Iterable}from"../../../base/common/iterator.js";import{Disposable,toDisposable}from"../../../base/common/lifecycle.js";import{LinkedList}from"../../../base/common/linkedList.js";import{validateConstraints}from"../../../base/common/types.js";import{createDecorator}from"../../instantiation/common/instantiation.js";export const ICommandService=createDecorator("commandService");export const CommandsRegistry=new class{constructor(){this._commands=new Map,this._onDidRegisterCommand=new Emitter,this.onDidRegisterCommand=this._onDidRegisterCommand.event}registerCommand(e,o){if(!e)throw new Error("invalid command");if("string"===typeof e){if(!o)throw new Error("invalid command");return this.registerCommand({id:e,handler:o})}if(e.description){const o=[];for(let n of e.description.args)o.push(n.constraint);const t=e.handler;e.handler=function(e,...n){return validateConstraints(n,o),t(e,...n)}}const{id:t}=e;let n=this._commands.get(t);n||(n=new LinkedList,this._commands.set(t,n));let s=n.unshift(e),i=toDisposable((()=>{s();const e=this._commands.get(t);(null===e||void 0===e?void 0:e.isEmpty())&&this._commands.delete(t)}));return this._onDidRegisterCommand.fire(t),i}registerCommandAlias(e,o){return CommandsRegistry.registerCommand(e,((e,...t)=>e.get(ICommandService).executeCommand(o,...t)))}getCommand(e){const o=this._commands.get(e);if(o&&!o.isEmpty())return Iterable.first(o)}getCommands(){const e=new Map;for(const o of this._commands.keys()){const t=this.getCommand(o);t&&e.set(o,t)}return e}};export const NullCommandService={_serviceBrand:void 0,onWillExecuteCommand:()=>Disposable.None,onDidExecuteCommand:()=>Disposable.None,executeCommand(){return Promise.resolve(void 0)}};CommandsRegistry.registerCommand("noop",(()=>{}));