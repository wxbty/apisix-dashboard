import*as languages from"../../../common/languages.js";import{NullState}from"../../../common/languages/nullMode.js";import*as monarchCommon from"./monarchCommon.js";const CACHE_STACK_DEPTH=5;class MonarchStackElementFactory{constructor(e){this._maxCacheDepth=e,this._entries=Object.create(null)}static create(e,t){return this._INSTANCE.create(e,t)}create(e,t){if(null!==e&&e.depth>=this._maxCacheDepth)return new MonarchStackElement(e,t);let n=MonarchStackElement.getStackElementId(e);n.length>0&&(n+="|"),n+=t;let a=this._entries[n];return a||(a=new MonarchStackElement(e,t),this._entries[n]=a,a)}}MonarchStackElementFactory._INSTANCE=new MonarchStackElementFactory(CACHE_STACK_DEPTH);class MonarchStackElement{constructor(e,t){this.parent=e,this.state=t,this.depth=(this.parent?this.parent.depth:0)+1}static getStackElementId(e){let t="";while(null!==e)t.length>0&&(t+="|"),t+=e.state,e=e.parent;return t}static _equals(e,t){while(null!==e&&null!==t){if(e===t)return!0;if(e.state!==t.state)return!1;e=e.parent,t=t.parent}return null===e&&null===t}equals(e){return MonarchStackElement._equals(this,e)}push(e){return MonarchStackElementFactory.create(this,e)}pop(){return this.parent}popall(){let e=this;while(e.parent)e=e.parent;return e}switchTo(e){return MonarchStackElementFactory.create(this.parent,e)}}class EmbeddedLanguageData{constructor(e,t){this.languageId=e,this.state=t}equals(e){return this.languageId===e.languageId&&this.state.equals(e.state)}clone(){const e=this.state.clone();return e===this.state?this:new EmbeddedLanguageData(this.languageId,this.state)}}class MonarchLineStateFactory{constructor(e){this._maxCacheDepth=e,this._entries=Object.create(null)}static create(e,t){return this._INSTANCE.create(e,t)}create(e,t){if(null!==t)return new MonarchLineState(e,t);if(null!==e&&e.depth>=this._maxCacheDepth)return new MonarchLineState(e,t);const n=MonarchStackElement.getStackElementId(e);let a=this._entries[n];return a||(a=new MonarchLineState(e,null),this._entries[n]=a,a)}}MonarchLineStateFactory._INSTANCE=new MonarchLineStateFactory(CACHE_STACK_DEPTH);class MonarchLineState{constructor(e,t){this.stack=e,this.embeddedLanguageData=t}clone(){const e=this.embeddedLanguageData?this.embeddedLanguageData.clone():null;return e===this.embeddedLanguageData?this:MonarchLineStateFactory.create(this.stack,this.embeddedLanguageData)}equals(e){return e instanceof MonarchLineState&&(!!this.stack.equals(e.stack)&&(null===this.embeddedLanguageData&&null===e.embeddedLanguageData||null!==this.embeddedLanguageData&&null!==e.embeddedLanguageData&&this.embeddedLanguageData.equals(e.embeddedLanguageData)))}}class MonarchClassicTokensCollector{constructor(){this._tokens=[],this._languageId=null,this._lastTokenType=null,this._lastTokenLanguage=null}enterLanguage(e){this._languageId=e}emit(e,t){this._lastTokenType===t&&this._lastTokenLanguage===this._languageId||(this._lastTokenType=t,this._lastTokenLanguage=this._languageId,this._tokens.push(new languages.Token(e,t,this._languageId)))}nestedLanguageTokenize(e,t,n,a){const r=n.languageId,s=n.state,o=languages.TokenizationRegistry.get(r);if(!o)return this.enterLanguage(r),this.emit(a,""),s;const i=o.tokenize(e,t,s);if(0!==a)for(const l of i.tokens)this._tokens.push(new languages.Token(l.offset+a,l.type,l.language));else this._tokens=this._tokens.concat(i.tokens);return this._lastTokenType=null,this._lastTokenLanguage=null,this._languageId=null,i.endState}finalize(e){return new languages.TokenizationResult(this._tokens,e)}}class MonarchModernTokensCollector{constructor(e,t){this._languageService=e,this._theme=t,this._prependTokens=null,this._tokens=[],this._currentLanguageId=0,this._lastTokenMetadata=0}enterLanguage(e){this._currentLanguageId=this._languageService.languageIdCodec.encodeLanguageId(e)}emit(e,t){const n=this._theme.match(this._currentLanguageId,t);this._lastTokenMetadata!==n&&(this._lastTokenMetadata=n,this._tokens.push(e),this._tokens.push(n))}static _merge(e,t,n){const a=null!==e?e.length:0,r=t.length,s=null!==n?n.length:0;if(0===a&&0===r&&0===s)return new Uint32Array(0);if(0===a&&0===r)return n;if(0===r&&0===s)return e;const o=new Uint32Array(a+r+s);null!==e&&o.set(e);for(let i=0;i<r;i++)o[a+i]=t[i];return null!==n&&o.set(n,a+r),o}nestedLanguageTokenize(e,t,n,a){const r=n.languageId,s=n.state,o=languages.TokenizationRegistry.get(r);if(!o)return this.enterLanguage(r),this.emit(a,""),s;const i=o.tokenizeEncoded(e,t,s);if(0!==a)for(let l=0,h=i.tokens.length;l<h;l+=2)i.tokens[l]+=a;return this._prependTokens=MonarchModernTokensCollector._merge(this._prependTokens,this._tokens,i.tokens),this._tokens=[],this._currentLanguageId=0,this._lastTokenMetadata=0,i.endState}finalize(e){return new languages.EncodedTokenizationResult(MonarchModernTokensCollector._merge(this._prependTokens,this._tokens,null),e)}}export class MonarchTokenizer{constructor(e,t,n,a){this._languageService=e,this._standaloneThemeService=t,this._languageId=n,this._lexer=a,this._embeddedLanguages=Object.create(null),this.embeddedLoaded=Promise.resolve(void 0);let r=!1;this._tokenizationRegistryListener=languages.TokenizationRegistry.onDidChange((e=>{if(r)return;let t=!1;for(let n=0,a=e.changedLanguages.length;n<a;n++){const a=e.changedLanguages[n];if(this._embeddedLanguages[a]){t=!0;break}}t&&(r=!0,languages.TokenizationRegistry.fire([this._languageId]),r=!1)}))}dispose(){this._tokenizationRegistryListener.dispose()}getLoadStatus(){const e=[];for(let t in this._embeddedLanguages){const n=languages.TokenizationRegistry.get(t);if(n){if(n instanceof MonarchTokenizer){const t=n.getLoadStatus();!1===t.loaded&&e.push(t.promise)}}else languages.TokenizationRegistry.isResolved(t)||e.push(languages.TokenizationRegistry.getOrCreate(t))}return 0===e.length?{loaded:!0}:{loaded:!1,promise:Promise.all(e).then((e=>{}))}}getInitialState(){const e=MonarchStackElementFactory.create(null,this._lexer.start);return MonarchLineStateFactory.create(e,null)}tokenize(e,t,n){const a=new MonarchClassicTokensCollector,r=this._tokenize(e,t,n,a);return a.finalize(r)}tokenizeEncoded(e,t,n){const a=new MonarchModernTokensCollector(this._languageService,this._standaloneThemeService.getColorTheme().tokenTheme),r=this._tokenize(e,t,n,a);return a.finalize(r)}_tokenize(e,t,n,a){return n.embeddedLanguageData?this._nestedTokenize(e,t,n,0,a):this._myTokenize(e,t,n,0,a)}_findLeavingNestedLanguageOffset(e,t){let n=this._lexer.tokenizer[t.stack.state];if(!n&&(n=monarchCommon.findRules(this._lexer,t.stack.state),!n))throw monarchCommon.createError(this._lexer,"tokenizer state is not defined: "+t.stack.state);let a=-1,r=!1;for(const s of n){if(!monarchCommon.isIAction(s.action)||"@pop"!==s.action.nextEmbedded)continue;r=!0;let t=s.regex;const n=s.regex.source;if("^(?:"===n.substr(0,4)&&")"===n.substr(n.length-1,1)){const e=(t.ignoreCase?"i":"")+(t.unicode?"u":"");t=new RegExp(n.substr(4,n.length-5),e)}const o=e.search(t);-1===o||0!==o&&s.matchOnlyAtLineStart||(-1===a||o<a)&&(a=o)}if(!r)throw monarchCommon.createError(this._lexer,'no rule containing nextEmbedded: "@pop" in tokenizer embedded state: '+t.stack.state);return a}_nestedTokenize(e,t,n,a,r){const s=this._findLeavingNestedLanguageOffset(e,n);if(-1===s){const s=r.nestedLanguageTokenize(e,t,n.embeddedLanguageData,a);return MonarchLineStateFactory.create(n.stack,new EmbeddedLanguageData(n.embeddedLanguageData.languageId,s))}const o=e.substring(0,s);o.length>0&&r.nestedLanguageTokenize(o,!1,n.embeddedLanguageData,a);const i=e.substring(s);return this._myTokenize(i,t,n,a+s,r)}_safeRuleName(e){return e?e.name:"(unknown)"}_myTokenize(e,t,n,a,r){r.enterLanguage(this._languageId);const s=e.length,o=t&&this._lexer.includeLF?e+"\n":e,i=o.length;let l=n.embeddedLanguageData,h=n.stack,c=0,u=null,g=!0;while(g||c<i){const n=c,d=h.depth,m=u?u.groups.length:0,_=h.state;let k=null,f=null,p=null,L=null,T=null;if(u){k=u.matches;const e=u.groups.shift();f=e.matched,p=e.action,L=u.rule,0===u.groups.length&&(u=null)}else{if(!g&&c>=i)break;g=!1;let e=this._lexer.tokenizer[_];if(!e&&(e=monarchCommon.findRules(this._lexer,_),!e))throw monarchCommon.createError(this._lexer,"tokenizer state is not defined: "+_);let t=o.substr(c);for(const n of e)if((0===c||!n.matchOnlyAtLineStart)&&(k=t.match(n.regex),k)){f=k[0],p=n.action;break}}if(k||(k=[""],f=""),p||(c<i&&(k=[o.charAt(c)],f=k[0]),p=this._lexer.defaultToken),null===f)break;c+=f.length;while(monarchCommon.isFuzzyAction(p)&&monarchCommon.isIAction(p)&&p.test)p=p.test(f,k,_,c===i);let b=null;if("string"===typeof p||Array.isArray(p))b=p;else if(p.group)b=p.group;else if(null!==p.token&&void 0!==p.token){if(b=p.tokenSubst?monarchCommon.substituteMatches(this._lexer,p.token,f,k,_):p.token,p.nextEmbedded)if("@pop"===p.nextEmbedded){if(!l)throw monarchCommon.createError(this._lexer,"cannot pop embedded language if not inside one");l=null}else{if(l)throw monarchCommon.createError(this._lexer,"cannot enter embedded language from within an embedded language");T=monarchCommon.substituteMatches(this._lexer,p.nextEmbedded,f,k,_)}if(p.goBack&&(c=Math.max(0,c-p.goBack)),p.switchTo&&"string"===typeof p.switchTo){let e=monarchCommon.substituteMatches(this._lexer,p.switchTo,f,k,_);if("@"===e[0]&&(e=e.substr(1)),!monarchCommon.findRules(this._lexer,e))throw monarchCommon.createError(this._lexer,"trying to switch to a state '"+e+"' that is undefined in rule: "+this._safeRuleName(L));h=h.switchTo(e)}else{if(p.transform&&"function"===typeof p.transform)throw monarchCommon.createError(this._lexer,"action.transform not supported");if(p.next)if("@push"===p.next){if(h.depth>=this._lexer.maxStack)throw monarchCommon.createError(this._lexer,"maximum tokenizer stack size reached: ["+h.state+","+h.parent.state+",...]");h=h.push(_)}else if("@pop"===p.next){if(h.depth<=1)throw monarchCommon.createError(this._lexer,"trying to pop an empty stack in rule: "+this._safeRuleName(L));h=h.pop()}else if("@popall"===p.next)h=h.popall();else{let e=monarchCommon.substituteMatches(this._lexer,p.next,f,k,_);if("@"===e[0]&&(e=e.substr(1)),!monarchCommon.findRules(this._lexer,e))throw monarchCommon.createError(this._lexer,"trying to set a next state '"+e+"' that is undefined in rule: "+this._safeRuleName(L));h=h.push(e)}}p.log&&"string"===typeof p.log&&monarchCommon.log(this._lexer,this._lexer.languageId+": "+monarchCommon.substituteMatches(this._lexer,p.log,f,k,_))}if(null===b)throw monarchCommon.createError(this._lexer,"lexer rule has no well-defined action in rule: "+this._safeRuleName(L));const C=n=>{const s=this._languageService.getLanguageIdByLanguageName(n)||this._languageService.getLanguageIdByMimeType(n)||n,o=this._getNestedEmbeddedLanguageData(s);if(c<i){const n=e.substr(c);return this._nestedTokenize(n,t,MonarchLineStateFactory.create(h,o),a+c,r)}return MonarchLineStateFactory.create(h,o)};if(Array.isArray(b)){if(u&&u.groups.length>0)throw monarchCommon.createError(this._lexer,"groups cannot be nested: "+this._safeRuleName(L));if(k.length!==b.length+1)throw monarchCommon.createError(this._lexer,"matched number of groups does not match the number of actions in rule: "+this._safeRuleName(L));let e=0;for(let t=1;t<k.length;t++)e+=k[t].length;if(e!==f.length)throw monarchCommon.createError(this._lexer,"with groups, all characters should be matched in consecutive groups in rule: "+this._safeRuleName(L));u={rule:L,matches:k,groups:[]};for(let t=0;t<b.length;t++)u.groups[t]={action:b[t],matched:k[t+1]};c-=f.length}else{{if("@rematch"===b&&(c-=f.length,f="",k=null,b="",null!==T))return C(T);if(0===f.length){if(0===i||d!==h.depth||_!==h.state||(u?u.groups.length:0)!==m)continue;throw monarchCommon.createError(this._lexer,"no progress in tokenizer in rule: "+this._safeRuleName(L))}let e=null;if(monarchCommon.isString(b)&&0===b.indexOf("@brackets")){const t=b.substr("@brackets".length),n=findBracket(this._lexer,f);if(!n)throw monarchCommon.createError(this._lexer,"@brackets token returned but no bracket defined as: "+f);e=monarchCommon.sanitize(n.token+t)}else{const t=""===b?"":b+this._lexer.tokenPostfix;e=monarchCommon.sanitize(t)}n<s&&r.emit(n+a,e)}if(null!==T)return C(T)}}return MonarchLineStateFactory.create(h,l)}_getNestedEmbeddedLanguageData(e){if(!this._languageService.isRegisteredLanguageId(e))return new EmbeddedLanguageData(e,NullState);e!==this._languageId&&(languages.TokenizationRegistry.getOrCreate(e),this._embeddedLanguages[e]=!0);const t=languages.TokenizationRegistry.get(e);return new EmbeddedLanguageData(e,t?t.getInitialState():NullState)}}function findBracket(e,t){if(!t)return null;t=monarchCommon.fixCase(e,t);const n=e.brackets;for(const a of n){if(a.open===t)return{token:a.token,bracketType:1};if(a.close===t)return{token:a.token,bracketType:-1}}return null}