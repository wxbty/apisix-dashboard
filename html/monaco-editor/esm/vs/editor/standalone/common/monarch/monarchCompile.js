import*as monarchCommon from"./monarchCommon.js";function isArrayOf(e,t){if(!t)return!1;if(!Array.isArray(t))return!1;for(const n of t)if(!e(n))return!1;return!0}function bool(e,t){return"boolean"===typeof e?e:t}function string(e,t){return"string"===typeof e?e:t}function arrayToHash(e){const t={};for(const n of e)t[n]=!0;return t}function createKeywordMatcher(e,t=!1){t&&(e=e.map((function(e){return e.toLowerCase()})));const n=arrayToHash(e);return t?function(e){return void 0!==n[e.toLowerCase()]&&n.hasOwnProperty(e.toLowerCase())}:function(e){return void 0!==n[e]&&n.hasOwnProperty(e)}}function compileRegExp(e,t){t=t.replace(/@@/g,"\x01");let n,r=0;do{n=!1,t=t.replace(/@(\w+)/g,(function(r,o){n=!0;let i="";if("string"===typeof e[o])i=e[o];else{if(!(e[o]&&e[o]instanceof RegExp))throw void 0===e[o]?monarchCommon.createError(e,"language definition does not contain attribute '"+o+"', used at: "+t):monarchCommon.createError(e,"attribute reference '"+o+"' must be a string, used at: "+t);i=e[o].source}return monarchCommon.empty(i)?"":"(?:"+i+")"})),r++}while(n&&r<5);t=t.replace(/\x01/g,"@");const o=(e.ignoreCase?"i":"")+(e.unicode?"u":"");return new RegExp(t,o)}function selectScrutinee(e,t,n,r){if(r<0)return e;if(r<t.length)return t[r];if(r>=100){r-=100;const e=n.split(".");if(e.unshift(n),r<e.length)return e[r]}return null}function createGuard(e,t,n,r){let o=-1,i=n,a=n.match(/^\$(([sS]?)(\d\d?)|#)(.*)$/);a&&(a[3]&&(o=parseInt(a[3]),a[2]&&(o+=100)),i=a[4]);let s,c="~",u=i;if(i&&0!==i.length?/^\w*$/.test(u)?c="==":(a=i.match(/^(@|!@|~|!~|==|!=)(.*)$/),a&&(c=a[1],u=a[2])):(c="!=",u=""),"~"!==c&&"!~"!==c||!/^(\w|\|)*$/.test(u))if("@"===c||"!@"===c){const n=e[u];if(!n)throw monarchCommon.createError(e,"the @ match target '"+u+"' is not defined, in rule: "+t);if(!isArrayOf((function(e){return"string"===typeof e}),n))throw monarchCommon.createError(e,"the @ match target '"+u+"' must be an array of strings, in rule: "+t);const r=createKeywordMatcher(n,e.ignoreCase);s=function(e){return"@"===c?r(e):!r(e)}}else if("~"===c||"!~"===c)if(u.indexOf("$")<0){const t=compileRegExp(e,"^"+u+"$");s=function(e){return"~"===c?t.test(e):!t.test(e)}}else s=function(t,n,r,o){const i=compileRegExp(e,"^"+monarchCommon.substituteMatches(e,u,n,r,o)+"$");return i.test(t)};else if(u.indexOf("$")<0){const t=monarchCommon.fixCase(e,u);s=function(e){return"=="===c?e===t:e!==t}}else{const t=monarchCommon.fixCase(e,u);s=function(n,r,o,i,a){const s=monarchCommon.substituteMatches(e,t,r,o,i);return"=="===c?n===s:n!==s}}else{const t=createKeywordMatcher(u.split("|"),e.ignoreCase);s=function(e){return"~"===c?t(e):!t(e)}}return-1===o?{name:n,value:r,test:function(e,t,n,r){return s(e,e,t,n,r)}}:{name:n,value:r,test:function(e,t,n,r){const i=selectScrutinee(e,t,n,o);return s(i||"",e,t,n,r)}}}function compileAction(e,t,n){if(n){if("string"===typeof n)return n;if(n.token||""===n.token){if("string"!==typeof n.token)throw monarchCommon.createError(e,"a 'token' attribute must be of type string, in rule: "+t);{const r={token:n.token};if(n.token.indexOf("$")>=0&&(r.tokenSubst=!0),"string"===typeof n.bracket)if("@open"===n.bracket)r.bracket=1;else{if("@close"!==n.bracket)throw monarchCommon.createError(e,"a 'bracket' attribute must be either '@open' or '@close', in rule: "+t);r.bracket=-1}if(n.next){if("string"!==typeof n.next)throw monarchCommon.createError(e,"the next state must be a string value in rule: "+t);{let o=n.next;if(!/^(@pop|@push|@popall)$/.test(o)&&("@"===o[0]&&(o=o.substr(1)),o.indexOf("$")<0&&!monarchCommon.stateExists(e,monarchCommon.substituteMatches(e,o,"",[],""))))throw monarchCommon.createError(e,"the next state '"+n.next+"' is not defined in rule: "+t);r.next=o}}return"number"===typeof n.goBack&&(r.goBack=n.goBack),"string"===typeof n.switchTo&&(r.switchTo=n.switchTo),"string"===typeof n.log&&(r.log=n.log),"string"===typeof n.nextEmbedded&&(r.nextEmbedded=n.nextEmbedded,e.usesEmbedded=!0),r}}if(Array.isArray(n)){const r=[];for(let o=0,i=n.length;o<i;o++)r[o]=compileAction(e,t,n[o]);return{group:r}}if(n.cases){const r=[];for(let i in n.cases)if(n.cases.hasOwnProperty(i)){const o=compileAction(e,t,n.cases[i]);"@default"===i||"@"===i||""===i?r.push({test:void 0,value:o,name:i}):"@eos"===i?r.push({test:function(e,t,n,r){return r},value:o,name:i}):r.push(createGuard(e,t,i,o))}const o=e.defaultToken;return{test:function(e,t,n,i){for(const o of r){const r=!o.test||o.test(e,t,n,i);if(r)return o.value}return o}}}throw monarchCommon.createError(e,"an action must be a string, an object with a 'token' or 'cases' attribute, or an array of actions; in rule: "+t)}return{token:""}}class Rule{constructor(e){this.regex=new RegExp(""),this.action={token:""},this.matchOnlyAtLineStart=!1,this.name="",this.name=e}setRegex(e,t){let n;if("string"===typeof t)n=t;else{if(!(t instanceof RegExp))throw monarchCommon.createError(e,"rules must start with a match string or regular expression: "+this.name);n=t.source}this.matchOnlyAtLineStart=n.length>0&&"^"===n[0],this.name=this.name+": "+n,this.regex=compileRegExp(e,"^(?:"+(this.matchOnlyAtLineStart?n.substr(1):n)+")")}setAction(e,t){this.action=compileAction(e,this.name,t)}}export function compile(e,t){if(!t||"object"!==typeof t)throw new Error("Monarch: expecting a language definition object");const n={};n.languageId=e,n.includeLF=bool(t.includeLF,!1),n.noThrow=!1,n.maxStack=100,n.start="string"===typeof t.start?t.start:null,n.ignoreCase=bool(t.ignoreCase,!1),n.unicode=bool(t.unicode,!1),n.tokenPostfix=string(t.tokenPostfix,"."+n.languageId),n.defaultToken=string(t.defaultToken,"source"),n.usesEmbedded=!1;const r=t;function o(e,i,a){for(const s of a){let a=s.include;if(a){if("string"!==typeof a)throw monarchCommon.createError(n,"an 'include' attribute must be a string at: "+e);if("@"===a[0]&&(a=a.substr(1)),!t.tokenizer[a])throw monarchCommon.createError(n,"include target '"+a+"' is not defined at: "+e);o(e+"."+a,i,t.tokenizer[a])}else{const t=new Rule(e);if(Array.isArray(s)&&s.length>=1&&s.length<=3)if(t.setRegex(r,s[0]),s.length>=3)if("string"===typeof s[1])t.setAction(r,{token:s[1],next:s[2]});else{if("object"!==typeof s[1])throw monarchCommon.createError(n,"a next state as the last element of a rule can only be given if the action is either an object or a string, at: "+e);{const e=s[1];e.next=s[2],t.setAction(r,e)}}else t.setAction(r,s[1]);else{if(!s.regex)throw monarchCommon.createError(n,"a rule must either be an array, or an object with a 'regex' or 'include' field at: "+e);s.name&&"string"===typeof s.name&&(t.name=s.name),s.matchOnlyAtStart&&(t.matchOnlyAtLineStart=bool(s.matchOnlyAtLineStart,!1)),t.setRegex(r,s.regex),t.setAction(r,s.action)}i.push(t)}}}if(r.languageId=e,r.includeLF=n.includeLF,r.ignoreCase=n.ignoreCase,r.unicode=n.unicode,r.noThrow=n.noThrow,r.usesEmbedded=n.usesEmbedded,r.stateNames=t.tokenizer,r.defaultToken=n.defaultToken,!t.tokenizer||"object"!==typeof t.tokenizer)throw monarchCommon.createError(n,"a language definition must define the 'tokenizer' attribute as an object");n.tokenizer=[];for(let a in t.tokenizer)if(t.tokenizer.hasOwnProperty(a)){n.start||(n.start=a);const e=t.tokenizer[a];n.tokenizer[a]=new Array,o("tokenizer."+a,n.tokenizer[a],e)}if(n.usesEmbedded=r.usesEmbedded,t.brackets){if(!Array.isArray(t.brackets))throw monarchCommon.createError(n,"the 'brackets' attribute must be defined as an array")}else t.brackets=[{open:"{",close:"}",token:"delimiter.curly"},{open:"[",close:"]",token:"delimiter.square"},{open:"(",close:")",token:"delimiter.parenthesis"},{open:"<",close:">",token:"delimiter.angle"}];const i=[];for(let a of t.brackets){let e=a;if(e&&Array.isArray(e)&&3===e.length&&(e={token:e[2],open:e[0],close:e[1]}),e.open===e.close)throw monarchCommon.createError(n,"open and close brackets in a 'brackets' attribute must be different: "+e.open+"\n hint: use the 'bracket' attribute if matching on equal brackets is required.");if("string"!==typeof e.open||"string"!==typeof e.token||"string"!==typeof e.close)throw monarchCommon.createError(n,"every element in the 'brackets' array must be a '{open,close,token}' object or array");i.push({token:e.token+n.tokenPostfix,open:monarchCommon.fixCase(n,e.open),close:monarchCommon.fixCase(n,e.close)})}return n.brackets=i,n.noThrow=!0,n}