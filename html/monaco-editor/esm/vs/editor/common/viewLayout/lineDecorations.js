import*as strings from"../../../base/common/strings.js";export class LineDecoration{constructor(t,s,e,n){this.startColumn=t,this.endColumn=s,this.className=e,this.type=n,this._lineDecorationBrand=void 0}static _equals(t,s){return t.startColumn===s.startColumn&&t.endColumn===s.endColumn&&t.className===s.className&&t.type===s.type}static equalsArr(t,s){const e=t.length,n=s.length;if(e!==n)return!1;for(let a=0;a<e;a++)if(!LineDecoration._equals(t[a],s[a]))return!1;return!0}static extractWrapped(t,s,e){if(0===t.length)return t;const n=s+1,a=e+1,o=e-s,i=[];let r=0;for(const c of t)c.endColumn<=n||c.startColumn>=a||(i[r++]=new LineDecoration(Math.max(1,c.startColumn-n+1),Math.min(o+1,c.endColumn-n+1),c.className,c.type));return i}static filter(t,s,e,n){if(0===t.length)return[];const a=[];let o=0;for(let i=0,r=t.length;i<r;i++){const r=t[i],c=r.range;if(c.endLineNumber<s||c.startLineNumber>s)continue;if(c.isEmpty()&&(0===r.type||3===r.type))continue;const l=c.startLineNumber===s?c.startColumn:e,m=c.endLineNumber===s?c.endColumn:n;a[o++]=new LineDecoration(l,m,r.inlineClassName,r.type)}return a}static _typeCompare(t,s){const e=[2,0,1,3];return e[t]-e[s]}static compare(t,s){if(t.startColumn!==s.startColumn)return t.startColumn-s.startColumn;if(t.endColumn!==s.endColumn)return t.endColumn-s.endColumn;const e=LineDecoration._typeCompare(t.type,s.type);return 0!==e?e:t.className!==s.className?t.className<s.className?-1:1:0}}export class DecorationSegment{constructor(t,s,e,n){this.startOffset=t,this.endOffset=s,this.className=e,this.metadata=n}}class Stack{constructor(){this.stopOffsets=[],this.classNames=[],this.metadata=[],this.count=0}static _metadata(t){let s=0;for(let e=0,n=t.length;e<n;e++)s|=t[e];return s}consumeLowerThan(t,s,e){while(this.count>0&&this.stopOffsets[0]<t){let t=0;while(t+1<this.count&&this.stopOffsets[t]===this.stopOffsets[t+1])t++;e.push(new DecorationSegment(s,this.stopOffsets[t],this.classNames.join(" "),Stack._metadata(this.metadata))),s=this.stopOffsets[t]+1,this.stopOffsets.splice(0,t+1),this.classNames.splice(0,t+1),this.metadata.splice(0,t+1),this.count-=t+1}return this.count>0&&s<t&&(e.push(new DecorationSegment(s,t-1,this.classNames.join(" "),Stack._metadata(this.metadata))),s=t),s}insert(t,s,e){if(0===this.count||this.stopOffsets[this.count-1]<=t)this.stopOffsets.push(t),this.classNames.push(s),this.metadata.push(e);else for(let n=0;n<this.count;n++)if(this.stopOffsets[n]>=t){this.stopOffsets.splice(n,0,t),this.classNames.splice(n,0,s),this.metadata.splice(n,0,e);break}this.count++}}export class LineDecorationsNormalizer{static normalize(t,s){if(0===s.length)return[];const e=[],n=new Stack;let a=0;for(let o=0,i=s.length;o<i;o++){const i=s[o];let r=i.startColumn,c=i.endColumn;const l=i.className,m=1===i.type?2:2===i.type?4:0;if(r>1){const s=t.charCodeAt(r-2);strings.isHighSurrogate(s)&&r--}if(c>1){const s=t.charCodeAt(c-2);strings.isHighSurrogate(s)&&c--}const u=r-1,h=c-2;a=n.consumeLowerThan(u,a,e),0===n.count&&(a=u),n.insert(h,l,m)}return n.consumeLowerThan(1073741824,a,e),e}}