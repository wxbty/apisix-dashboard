import{assertNever}from"../../../base/common/types.js";import{Position}from"../core/position.js";import{InjectedTextCursorStops}from"../model.js";export class ModelLineProjectionData{constructor(t,e,n,i,s){this.injectionOffsets=t,this.injectionOptions=e,this.breakOffsets=n,this.breakOffsetsVisibleColumn=i,this.wrappedTextIndentLength=s}getOutputLineCount(){return this.breakOffsets.length}getMinOutputOffset(t){return t>0?this.wrappedTextIndentLength:0}getLineLength(t){const e=t>0?this.breakOffsets[t-1]:0,n=this.breakOffsets[t];let i=n-e;return t>0&&(i+=this.wrappedTextIndentLength),i}getMaxOutputOffset(t){return this.getLineLength(t)}translateToInputOffset(t,e){t>0&&(e=Math.max(0,e-this.wrappedTextIndentLength));const n=0===t?e:this.breakOffsets[t-1]+e;let i=n;if(null!==this.injectionOffsets)for(let s=0;s<this.injectionOffsets.length;s++){if(!(i>this.injectionOffsets[s]))break;i<this.injectionOffsets[s]+this.injectionOptions[s].content.length?i=this.injectionOffsets[s]:i-=this.injectionOptions[s].content.length}return i}translateToOutputPosition(t,e=2){let n=t;if(null!==this.injectionOffsets)for(let i=0;i<this.injectionOffsets.length;i++){if(t<this.injectionOffsets[i])break;if(1!==e&&t===this.injectionOffsets[i])break;n+=this.injectionOptions[i].content.length}return this.offsetInInputWithInjectionsToOutputPosition(n,e)}offsetInInputWithInjectionsToOutputPosition(t,e=2){let n=0,i=this.breakOffsets.length-1,s=0,o=0;while(n<=i){s=n+(i-n)/2|0;const f=this.breakOffsets[s];if(o=s>0?this.breakOffsets[s-1]:0,0===e)if(t<=o)i=s-1;else{if(!(t>f))break;n=s+1}else if(t<o)i=s-1;else{if(!(t>=f))break;n=s+1}}let f=t-o;return s>0&&(f+=this.wrappedTextIndentLength),new OutputPosition(s,f)}normalizeOutputPosition(t,e,n){if(null!==this.injectionOffsets){const i=this.outputPositionToOffsetInInputWithInjections(t,e),s=this.normalizeOffsetInInputWithInjectionsAroundInjections(i,n);if(s!==i)return this.offsetInInputWithInjectionsToOutputPosition(s,n)}if(0===n){if(t>0&&e===this.getMinOutputOffset(t))return new OutputPosition(t-1,this.getMaxOutputOffset(t-1))}else if(1===n){const n=this.getOutputLineCount()-1;if(t<n&&e===this.getMaxOutputOffset(t))return new OutputPosition(t+1,this.getMinOutputOffset(t+1))}return new OutputPosition(t,e)}outputPositionToOffsetInInputWithInjections(t,e){t>0&&(e=Math.max(0,e-this.wrappedTextIndentLength));const n=(t>0?this.breakOffsets[t-1]:0)+e;return n}normalizeOffsetInInputWithInjectionsAroundInjections(t,e){const n=this.getInjectedTextAtOffset(t);if(!n)return t;if(2===e){if(t===n.offsetInInputWithInjections+n.length&&hasRightCursorStop(this.injectionOptions[n.injectedTextIndex].cursorStops))return n.offsetInInputWithInjections+n.length;{let t=n.offsetInInputWithInjections;if(hasLeftCursorStop(this.injectionOptions[n.injectedTextIndex].cursorStops))return t;let e=n.injectedTextIndex-1;while(e>=0&&this.injectionOffsets[e]===this.injectionOffsets[n.injectedTextIndex]){if(hasRightCursorStop(this.injectionOptions[e].cursorStops))break;if(t-=this.injectionOptions[e].content.length,hasLeftCursorStop(this.injectionOptions[e].cursorStops))break;e--}return t}}if(1===e){let t=n.offsetInInputWithInjections+n.length,e=n.injectedTextIndex;while(e+1<this.injectionOffsets.length&&this.injectionOffsets[e+1]===this.injectionOffsets[e])t+=this.injectionOptions[e+1].content.length,e++;return t}if(0===e){let t=n.offsetInInputWithInjections,e=n.injectedTextIndex;while(e-1>=0&&this.injectionOffsets[e-1]===this.injectionOffsets[e])t-=this.injectionOptions[e-1].content.length,e--;return t}assertNever(e)}getInjectedText(t,e){const n=this.outputPositionToOffsetInInputWithInjections(t,e),i=this.getInjectedTextAtOffset(n);return i?{options:this.injectionOptions[i.injectedTextIndex]}:null}getInjectedTextAtOffset(t){const e=this.injectionOffsets,n=this.injectionOptions;if(null!==e){let i=0;for(let s=0;s<e.length;s++){const o=n[s].content.length,f=e[s]+i,r=e[s]+i+o;if(f>t)break;if(t<=r)return{injectedTextIndex:s,offsetInInputWithInjections:f,length:o};i+=o}}}}function hasRightCursorStop(t){return null===t||void 0===t||(t===InjectedTextCursorStops.Right||t===InjectedTextCursorStops.Both)}function hasLeftCursorStop(t){return null===t||void 0===t||(t===InjectedTextCursorStops.Left||t===InjectedTextCursorStops.Both)}export class InjectedText{constructor(t){this.options=t}}export class OutputPosition{constructor(t,e){this.outputLineIndex=t,this.outputOffset=e}toString(){return`${this.outputLineIndex}:${this.outputOffset}`}toPosition(t){return new Position(t+this.outputLineIndex,this.outputOffset+1)}}