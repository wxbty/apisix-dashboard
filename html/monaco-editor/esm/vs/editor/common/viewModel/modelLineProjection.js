import{LineTokens}from"../tokens/lineTokens.js";import{Position}from"../core/position.js";import{LineInjectedText}from"../textModelEvents.js";import{SingleLineInlineDecoration,ViewLineData}from"./viewModel.js";export function createModelLineProjection(e,t){return null===e?t?IdentityModelLineProjection.INSTANCE:HiddenModelLineProjection.INSTANCE:new ModelLineProjection(e,t)}class ModelLineProjection{constructor(e,t){this._projectionData=e,this._isVisible=t}isVisible(){return this._isVisible}setVisible(e){return this._isVisible=e,this}getProjectionData(){return this._projectionData}getViewLineCount(){return this._isVisible?this._projectionData.getOutputLineCount():0}getViewLineContent(e,t,n){this._assertVisible();const i=n>0?this._projectionData.breakOffsets[n-1]:0,o=this._projectionData.breakOffsets[n];let r;if(null!==this._projectionData.injectionOffsets){const n=this._projectionData.injectionOffsets.map(((e,t)=>new LineInjectedText(0,0,e+1,this._projectionData.injectionOptions[t],0))),s=LineInjectedText.applyInjectedText(e.getLineContent(t),n);r=s.substring(i,o)}else r=e.getValueInRange({startLineNumber:t,startColumn:i+1,endLineNumber:t,endColumn:o+1});return n>0&&(r=spaces(this._projectionData.wrappedTextIndentLength)+r),r}getViewLineLength(e,t,n){return this._assertVisible(),this._projectionData.getLineLength(n)}getViewLineMinColumn(e,t,n){return this._assertVisible(),this._projectionData.getMinOutputOffset(n)+1}getViewLineMaxColumn(e,t,n){return this._assertVisible(),this._projectionData.getMaxOutputOffset(n)+1}getViewLineData(e,t,n){const i=new Array;return this.getViewLinesData(e,t,n,1,0,[!0],i),i[0]}getViewLinesData(e,t,n,i,o,r,s){this._assertVisible();const a=this._projectionData,l=a.injectionOffsets,u=a.injectionOptions;let c,p=null;if(l){p=[];let e=0,t=0;for(let n=0;n<a.getOutputLineCount();n++){const i=new Array;p[n]=i;const o=n>0?a.breakOffsets[n-1]:0,r=a.breakOffsets[n];while(t<l.length){const s=u[t].content.length,c=l[t]+e,p=c+s;if(c>r)break;if(o<p){const e=u[t];if(e.inlineClassName){const t=n>0?a.wrappedTextIndentLength:0,s=t+Math.max(c-o,0),l=t+Math.min(p-o,r);s!==l&&i.push(new SingleLineInlineDecoration(s,l,e.inlineClassName,e.inlineClassNameAffectsLetterSpacing))}}if(!(p<=r))break;e+=s,t++}}}c=l?e.getLineTokens(t).withInserted(l.map(((e,t)=>({offset:e,text:u[t].content,tokenMetadata:LineTokens.defaultTokenMetadata})))):e.getLineTokens(t);for(let w=n;w<n+i;w++){const e=o+w-n;r[e]?s[e]=this._getViewLineData(c,p?p[w]:null,w):s[e]=null}}_getViewLineData(e,t,n){this._assertVisible();const i=this._projectionData,o=n>0?i.wrappedTextIndentLength:0,r=n>0?i.breakOffsets[n-1]:0,s=i.breakOffsets[n],a=e.sliceAndInflate(r,s,o);let l=a.getLineContent();n>0&&(l=spaces(i.wrappedTextIndentLength)+l);const u=this._projectionData.getMinOutputOffset(n)+1,c=l.length+1,p=n+1<this.getViewLineCount(),w=0===n?0:i.breakOffsetsVisibleColumn[n-1];return new ViewLineData(l,p,u,c,w,a,t)}getModelColumnOfViewPosition(e,t){return this._assertVisible(),this._projectionData.translateToInputOffset(e,t-1)+1}getViewPositionOfModelPosition(e,t,n=2){this._assertVisible();const i=this._projectionData.translateToOutputPosition(t-1,n);return i.toPosition(e)}getViewLineNumberOfModelPosition(e,t){this._assertVisible();const n=this._projectionData.translateToOutputPosition(t-1);return e+n.outputLineIndex}normalizePosition(e,t,n){const i=t.lineNumber-e,o=this._projectionData.normalizeOutputPosition(e,t.column-1,n),r=o.toPosition(i);return r}getInjectedTextAt(e,t){return this._projectionData.getInjectedText(e,t-1)}_assertVisible(){if(!this._isVisible)throw new Error("Not supported")}}class IdentityModelLineProjection{constructor(){}isVisible(){return!0}setVisible(e){return e?this:HiddenModelLineProjection.INSTANCE}getProjectionData(){return null}getViewLineCount(){return 1}getViewLineContent(e,t,n){return e.getLineContent(t)}getViewLineLength(e,t,n){return e.getLineLength(t)}getViewLineMinColumn(e,t,n){return e.getLineMinColumn(t)}getViewLineMaxColumn(e,t,n){return e.getLineMaxColumn(t)}getViewLineData(e,t,n){const i=e.getLineTokens(t),o=i.getLineContent();return new ViewLineData(o,!1,1,o.length+1,0,i.inflate(),null)}getViewLinesData(e,t,n,i,o,r,s){r[o]?s[o]=this.getViewLineData(e,t,0):s[o]=null}getModelColumnOfViewPosition(e,t){return t}getViewPositionOfModelPosition(e,t){return new Position(e,t)}getViewLineNumberOfModelPosition(e,t){return e}normalizePosition(e,t,n){return t}getInjectedTextAt(e,t){return null}}IdentityModelLineProjection.INSTANCE=new IdentityModelLineProjection;class HiddenModelLineProjection{constructor(){}isVisible(){return!1}setVisible(e){return e?IdentityModelLineProjection.INSTANCE:this}getProjectionData(){return null}getViewLineCount(){return 0}getViewLineContent(e,t,n){throw new Error("Not supported")}getViewLineLength(e,t,n){throw new Error("Not supported")}getViewLineMinColumn(e,t,n){throw new Error("Not supported")}getViewLineMaxColumn(e,t,n){throw new Error("Not supported")}getViewLineData(e,t,n){throw new Error("Not supported")}getViewLinesData(e,t,n,i,o,r,s){throw new Error("Not supported")}getModelColumnOfViewPosition(e,t){throw new Error("Not supported")}getViewPositionOfModelPosition(e,t){throw new Error("Not supported")}getViewLineNumberOfModelPosition(e,t){throw new Error("Not supported")}normalizePosition(e,t,n){throw new Error("Not supported")}getInjectedTextAt(e,t){throw new Error("Not supported")}}HiddenModelLineProjection.INSTANCE=new HiddenModelLineProjection;let _spaces=[""];function spaces(e){if(e>=_spaces.length)for(let t=1;t<=e;t++)_spaces[t]=_makeSpaces(t);return _spaces[e]}function _makeSpaces(e){return new Array(e+1).join(" ")}