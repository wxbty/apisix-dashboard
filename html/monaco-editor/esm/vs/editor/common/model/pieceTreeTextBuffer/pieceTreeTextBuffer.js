import{Emitter}from"../../../../base/common/event.js";import*as strings from"../../../../base/common/strings.js";import{Range}from"../../core/range.js";import{ApplyEditsResult}from"../../model.js";import{PieceTreeBase}from"./pieceTreeBase.js";import{countEOL}from"../../core/eolCounter.js";import{TextChange}from"../../core/textChange.js";import{Disposable}from"../../../../base/common/lifecycle.js";export class PieceTreeTextBuffer extends Disposable{constructor(e,t,n,r,i,s,o){super(),this._onDidChangeContent=this._register(new Emitter),this._BOM=t,this._mightContainNonBasicASCII=!s,this._mightContainRTL=r,this._mightContainUnusualLineTerminators=i,this._pieceTree=new PieceTreeBase(e,n,o)}mightContainRTL(){return this._mightContainRTL}mightContainUnusualLineTerminators(){return this._mightContainUnusualLineTerminators}resetMightContainUnusualLineTerminators(){this._mightContainUnusualLineTerminators=!1}mightContainNonBasicASCII(){return this._mightContainNonBasicASCII}getBOM(){return this._BOM}getEOL(){return this._pieceTree.getEOL()}createSnapshot(e){return this._pieceTree.createSnapshot(e?this._BOM:"")}getOffsetAt(e,t){return this._pieceTree.getOffsetAt(e,t)}getPositionAt(e){return this._pieceTree.getPositionAt(e)}getRangeAt(e,t){const n=e+t,r=this.getPositionAt(e),i=this.getPositionAt(n);return new Range(r.lineNumber,r.column,i.lineNumber,i.column)}getValueInRange(e,t=0){if(e.isEmpty())return"";const n=this._getEndOfLine(t);return this._pieceTree.getValueInRange(e,n)}getValueLengthInRange(e,t=0){if(e.isEmpty())return 0;if(e.startLineNumber===e.endLineNumber)return e.endColumn-e.startColumn;const n=this.getOffsetAt(e.startLineNumber,e.startColumn),r=this.getOffsetAt(e.endLineNumber,e.endColumn);return r-n}getCharacterCountInRange(e,t=0){if(this._mightContainNonBasicASCII){let n=0;const r=e.startLineNumber,i=e.endLineNumber;for(let t=r;t<=i;t++){const s=this.getLineContent(t),o=t===r?e.startColumn-1:0,a=t===i?e.endColumn-1:s.length;for(let e=o;e<a;e++)strings.isHighSurrogate(s.charCodeAt(e))?(n+=1,e+=1):n+=1}return n+=this._getEndOfLine(t).length*(i-r),n}return this.getValueLengthInRange(e,t)}getLength(){return this._pieceTree.getLength()}getLineCount(){return this._pieceTree.getLineCount()}getLinesContent(){return this._pieceTree.getLinesContent()}getLineContent(e){return this._pieceTree.getLineContent(e)}getLineCharCode(e,t){return this._pieceTree.getLineCharCode(e,t)}getLineLength(e){return this._pieceTree.getLineLength(e)}getLineFirstNonWhitespaceColumn(e){const t=strings.firstNonWhitespaceIndex(this.getLineContent(e));return-1===t?0:t+1}getLineLastNonWhitespaceColumn(e){const t=strings.lastNonWhitespaceIndex(this.getLineContent(e));return-1===t?0:t+2}_getEndOfLine(e){switch(e){case 1:return"\n";case 2:return"\r\n";case 0:return this.getEOL();default:throw new Error("Unknown EOL preference")}}setEOL(e){this._pieceTree.setEOL(e)}applyEdits(e,t,n){let r=this._mightContainRTL,i=this._mightContainUnusualLineTerminators,s=this._mightContainNonBasicASCII,o=!0,a=[];for(let f=0;f<e.length;f++){const t=e[f];o&&t._isTracked&&(o=!1);const n=t.range;if(t.text){let e=!0;s||(e=!strings.isBasicASCII(t.text),s=e),!r&&e&&(r=strings.containsRTL(t.text)),!i&&e&&(i=strings.containsUnusualLineTerminators(t.text))}let g="",u=0,h=0,l=0;if(t.text){let e;[u,h,l,e]=countEOL(t.text);const n=this.getEOL(),r="\r\n"===n?2:1;g=0===e||e===r?t.text:t.text.replace(/\r\n|\r|\n/g,n)}a[f]={sortIndex:f,identifier:t.identifier||null,range:n,rangeOffset:this.getOffsetAt(n.startLineNumber,n.startColumn),rangeLength:this.getValueLengthInRange(n),text:g,eolCount:u,firstLineLength:h,lastLineLength:l,forceMoveMarkers:Boolean(t.forceMoveMarkers),isAutoWhitespaceEdit:t.isAutoWhitespaceEdit||!1}}a.sort(PieceTreeTextBuffer._sortOpsAscending);let g=!1;for(let f=0,L=a.length-1;f<L;f++){const e=a[f].range.getEndPosition(),t=a[f+1].range.getStartPosition();if(t.isBeforeOrEqual(e)){if(t.isBefore(e))throw new Error("Overlapping ranges are not allowed!");g=!0}}o&&(a=this._reduceOperations(a));const u=n||t?PieceTreeTextBuffer._getInverseEditRanges(a):[],h=[];if(t)for(let f=0;f<a.length;f++){const e=a[f],t=u[f];if(e.isAutoWhitespaceEdit&&e.range.isEmpty())for(let n=t.startLineNumber;n<=t.endLineNumber;n++){let r="";n===t.startLineNumber&&(r=this.getLineContent(e.range.startLineNumber),-1!==strings.firstNonWhitespaceIndex(r))||h.push({lineNumber:n,oldContent:r})}}let l=null;if(n){let e=0;l=[];for(let t=0;t<a.length;t++){const n=a[t],r=u[t],i=this.getValueInRange(n.range),s=n.rangeOffset+e;e+=n.text.length-i.length,l[t]={sortIndex:n.sortIndex,identifier:n.identifier,range:r,text:i,textChange:new TextChange(n.rangeOffset,i,s,n.text)}}g||l.sort(((e,t)=>e.sortIndex-t.sortIndex))}this._mightContainRTL=r,this._mightContainUnusualLineTerminators=i,this._mightContainNonBasicASCII=s;const c=this._doApplyEdits(a);let m=null;if(t&&h.length>0){h.sort(((e,t)=>t.lineNumber-e.lineNumber)),m=[];for(let e=0,t=h.length;e<t;e++){const t=h[e].lineNumber;if(e>0&&h[e-1].lineNumber===t)continue;const n=h[e].oldContent,r=this.getLineContent(t);0!==r.length&&r!==n&&-1===strings.firstNonWhitespaceIndex(r)&&m.push(t)}}return this._onDidChangeContent.fire(),new ApplyEditsResult(l,c,m)}_reduceOperations(e){return e.length<1e3?e:[this._toSingleEditOperation(e)]}_toSingleEditOperation(e){let t=!1;const n=e[0].range,r=e[e.length-1].range,i=new Range(n.startLineNumber,n.startColumn,r.endLineNumber,r.endColumn);let s=n.startLineNumber,o=n.startColumn;const a=[];for(let c=0,m=e.length;c<m;c++){const n=e[c],r=n.range;t=t||n.forceMoveMarkers,a.push(this.getValueInRange(new Range(s,o,r.startLineNumber,r.startColumn))),n.text.length>0&&a.push(n.text),s=r.endLineNumber,o=r.endColumn}const g=a.join(""),[u,h,l]=countEOL(g);return{sortIndex:0,identifier:e[0].identifier,range:i,rangeOffset:this.getOffsetAt(i.startLineNumber,i.startColumn),rangeLength:this.getValueLengthInRange(i,0),text:g,eolCount:u,firstLineLength:h,lastLineLength:l,forceMoveMarkers:t,isAutoWhitespaceEdit:!1}}_doApplyEdits(e){e.sort(PieceTreeTextBuffer._sortOpsDescending);const t=[];for(let n=0;n<e.length;n++){const r=e[n],i=r.range.startLineNumber,s=r.range.startColumn,o=r.range.endLineNumber,a=r.range.endColumn;if(i===o&&s===a&&0===r.text.length)continue;r.text?(this._pieceTree.delete(r.rangeOffset,r.rangeLength),this._pieceTree.insert(r.rangeOffset,r.text,!0)):this._pieceTree.delete(r.rangeOffset,r.rangeLength);const g=new Range(i,s,o,a);t.push({range:g,rangeLength:r.rangeLength,text:r.text,rangeOffset:r.rangeOffset,forceMoveMarkers:r.forceMoveMarkers})}return t}findMatchesLineByLine(e,t,n,r){return this._pieceTree.findMatchesLineByLine(e,t,n,r)}static _getInverseEditRanges(e){const t=[];let n=0,r=0,i=null;for(let s=0,o=e.length;s<o;s++){const o=e[s];let a,g,u;if(i?i.range.endLineNumber===o.range.startLineNumber?(a=n,g=r+(o.range.startColumn-i.range.endColumn)):(a=n+(o.range.startLineNumber-i.range.endLineNumber),g=o.range.startColumn):(a=o.range.startLineNumber,g=o.range.startColumn),o.text.length>0){const e=o.eolCount+1;u=1===e?new Range(a,g,a,g+o.firstLineLength):new Range(a,g,a+e-1,o.lastLineLength+1)}else u=new Range(a,g,a,g);n=u.endLineNumber,r=u.endColumn,t.push(u),i=o}return t}static _sortOpsAscending(e,t){const n=Range.compareRangesUsingEnds(e.range,t.range);return 0===n?e.sortIndex-t.sortIndex:n}static _sortOpsDescending(e,t){const n=Range.compareRangesUsingEnds(e.range,t.range);return 0===n?t.sortIndex-e.sortIndex:-n}}