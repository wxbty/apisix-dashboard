import{InvalidBracketAstNode,ListAstNode,PairAstNode}from"./ast.js";import{BeforeEditPositionMapper}from"./beforeEditPositionMapper.js";import{SmallImmutableSet}from"./smallImmutableSet.js";import{lengthIsZero,lengthLessThan}from"./length.js";import{concat23Trees,concat23TreesOfSameHeight}from"./concat23Trees.js";import{NodeReader}from"./nodeReader.js";export function parseDocument(e,t,s,r){const o=new Parser(e,t,s,r);return o.parseDocument()}class Parser{constructor(e,t,s,r){if(this.tokenizer=e,this.createImmutableLists=r,this._itemsConstructed=0,this._itemsFromCache=0,s&&r)throw new Error("Not supported");this.oldNodeReader=s?new NodeReader(s):void 0,this.positionMapper=new BeforeEditPositionMapper(t,e.length)}parseDocument(){this._itemsConstructed=0,this._itemsFromCache=0;let e=this.parseList(SmallImmutableSet.getEmpty());return e||(e=ListAstNode.getEmpty()),e}parseList(e){const t=new Array;while(1){const s=this.tokenizer.peek();if(!s||2===s.kind&&s.bracketIds.intersects(e))break;const r=this.parseChild(e);4===r.kind&&0===r.childrenLength||t.push(r)}const s=this.oldNodeReader?concat23Trees(t):concat23TreesOfSameHeight(t,this.createImmutableLists);return s}parseChild(e){if(this.oldNodeReader){const t=this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);if(!lengthIsZero(t)){const s=this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset),(s=>{if(!lengthLessThan(s.length,t))return!1;const r=s.canBeReused(e);return r}));if(s)return this._itemsFromCache++,this.tokenizer.skip(s.length),s}}this._itemsConstructed++;const t=this.tokenizer.read();switch(t.kind){case 2:return new InvalidBracketAstNode(t.bracketIds,t.length);case 0:return t.astNode;case 1:{const s=e.merge(t.bracketIds),r=this.parseList(s),o=this.tokenizer.peek();return o&&2===o.kind&&(o.bracketId===t.bracketId||o.bracketIds.intersects(t.bracketIds))?(this.tokenizer.read(),PairAstNode.create(t.astNode,r,o.astNode)):PairAstNode.create(t.astNode,r,null)}default:throw new Error("unexpected")}}}