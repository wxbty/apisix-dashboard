import{NotSupportedError}from"../../../../../base/common/errors.js";import{TokenMetadata}from"../../../languages.js";import{TextAstNode}from"./ast.js";import{lengthAdd,lengthDiff,lengthGetColumnCountIfZeroLineCount,lengthToObj,lengthZero,toLength}from"./length.js";import{SmallImmutableSet}from"./smallImmutableSet.js";export class Token{constructor(e,t,n,s,i){this.length=e,this.kind=t,this.bracketId=n,this.bracketIds=s,this.astNode=i}}export class TextBufferTokenizer{constructor(e,t){this.textModel=e,this.bracketTokens=t,this.reader=new NonPeekableTextBufferTokenizer(this.textModel,this.bracketTokens),this._offset=lengthZero,this.didPeek=!1,this.peeked=null,this.textBufferLineCount=e.getLineCount(),this.textBufferLastLineLength=e.getLineLength(this.textBufferLineCount)}get offset(){return this._offset}get length(){return toLength(this.textBufferLineCount,this.textBufferLastLineLength)}skip(e){this.didPeek=!1,this._offset=lengthAdd(this._offset,e);const t=lengthToObj(this._offset);this.reader.setPosition(t.lineCount,t.columnCount)}read(){let e;return this.peeked?(this.didPeek=!1,e=this.peeked):e=this.reader.read(),e&&(this._offset=lengthAdd(this._offset,e.length)),e}peek(){return this.didPeek||(this.peeked=this.reader.read(),this.didPeek=!0),this.peeked}}class NonPeekableTextBufferTokenizer{constructor(e,t){this.textModel=e,this.bracketTokens=t,this.lineIdx=0,this.line=null,this.lineCharOffset=0,this.lineTokens=null,this.lineTokenOffset=0,this.peekedToken=null,this.textBufferLineCount=e.getLineCount(),this.textBufferLastLineLength=e.getLineLength(this.textBufferLineCount)}setPosition(e,t){e===this.lineIdx?(this.lineCharOffset=t,this.lineTokenOffset=0===this.lineCharOffset?0:this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset)):(this.lineIdx=e,this.lineCharOffset=t,this.line=null),this.peekedToken=null}read(){if(this.peekedToken){const e=this.peekedToken;return this.peekedToken=null,this.lineCharOffset+=lengthGetColumnCountIfZeroLineCount(e.length),e}if(this.lineIdx>this.textBufferLineCount-1||this.lineIdx===this.textBufferLineCount-1&&this.lineCharOffset>=this.textBufferLastLineLength)return null;null===this.line&&(this.lineTokens=this.textModel.getLineTokens(this.lineIdx+1),this.line=this.lineTokens.getLineContent(),this.lineTokenOffset=0===this.lineCharOffset?0:this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset));const e=this.lineIdx,t=this.lineCharOffset;let n=0;while(1){const s=this.lineTokens,i=s.getCount();let h=null;if(this.lineTokenOffset<i){const o=s.getMetadata(this.lineTokenOffset);while(this.lineTokenOffset+1<i&&o===s.getMetadata(this.lineTokenOffset+1))this.lineTokenOffset++;const l=0===TokenMetadata.getTokenType(o),f=s.getEndOffset(this.lineTokenOffset);if(l&&f!==this.lineCharOffset){const e=s.getLanguageId(this.lineTokenOffset),t=this.line.substring(this.lineCharOffset,f),n=this.bracketTokens.getSingleLanguageBracketTokens(e),i=n.regExpGlobal;if(i){i.lastIndex=0;const e=i.exec(t);e&&(h=n.getToken(e[0]),h&&(this.lineCharOffset+=e.index))}}if(n+=f-this.lineCharOffset,h){if(e!==this.lineIdx||t!==this.lineCharOffset){this.peekedToken=h;break}return this.lineCharOffset+=lengthGetColumnCountIfZeroLineCount(h.length),h}this.lineTokenOffset++,this.lineCharOffset=f}else{if(this.lineIdx===this.textBufferLineCount-1)break;if(this.lineIdx++,this.lineTokens=this.textModel.getLineTokens(this.lineIdx+1),this.lineTokenOffset=0,this.line=this.lineTokens.getLineContent(),this.lineCharOffset=0,n+=33,n>1e3)break}if(n>1500)break}const s=lengthDiff(e,t,this.lineIdx,this.lineCharOffset);return new Token(s,0,-1,SmallImmutableSet.getEmpty(),new TextAstNode(s))}}export class FastTokenizer{constructor(e,t){this.text=e,this._offset=lengthZero,this.idx=0;const n=t.getRegExpStr(),s=n?new RegExp(t.getRegExpStr()+"|\n","g"):null,i=[];let h,o=0,l=0,f=0,r=0;const a=new Array;for(let d=0;d<60;d++)a.push(new Token(toLength(0,d),0,-1,SmallImmutableSet.getEmpty(),new TextAstNode(toLength(0,d))));const k=new Array;for(let d=0;d<60;d++)k.push(new Token(toLength(1,d),0,-1,SmallImmutableSet.getEmpty(),new TextAstNode(toLength(1,d))));if(s){s.lastIndex=0;while(null!==(h=s.exec(e))){const e=h.index,n=h[0];if("\n"===n)o++,l=e+1;else{if(f!==e){let t;if(r===o){const n=e-f;if(n<a.length)t=a[n];else{const e=toLength(0,n);t=new Token(e,0,-1,SmallImmutableSet.getEmpty(),new TextAstNode(e))}}else{const n=o-r,s=e-l;if(1===n&&s<k.length)t=k[s];else{const e=toLength(n,s);t=new Token(e,0,-1,SmallImmutableSet.getEmpty(),new TextAstNode(e))}}i.push(t)}i.push(t.getToken(n)),f=e+n.length,r=o}}}const u=e.length;if(f!==u){const e=r===o?toLength(0,u-f):toLength(o-r,u-l);i.push(new Token(e,0,-1,SmallImmutableSet.getEmpty(),new TextAstNode(e)))}this.length=toLength(o,u-l),this.tokens=i}get offset(){return this._offset}read(){return this.tokens[this.idx++]||null}peek(){return this.tokens[this.idx]||null}skip(e){throw new NotSupportedError}}