const emptyArr=new Array;export class SmallImmutableSet{constructor(t,e){this.items=t,this.additionalItems=e}static create(t,e){if(t<=128&&0===e.length){let i=SmallImmutableSet.cache[t];return i||(i=new SmallImmutableSet(t,e),SmallImmutableSet.cache[t]=i),i}return new SmallImmutableSet(t,e)}static getEmpty(){return this.empty}add(t,e){const i=e.getKey(t);let m=i>>5;if(0===m){const t=1<<i|this.items;return t===this.items?this:SmallImmutableSet.create(t,this.additionalItems)}m--;const s=this.additionalItems.slice(0);while(s.length<m)s.push(0);return s[m]|=1<<(31&i),SmallImmutableSet.create(this.items,s)}merge(t){const e=this.items|t.items;if(this.additionalItems===emptyArr&&t.additionalItems===emptyArr)return e===this.items?this:e===t.items?t:SmallImmutableSet.create(e,emptyArr);const i=new Array;for(let m=0;m<Math.max(this.additionalItems.length,t.additionalItems.length);m++){const e=this.additionalItems[m]||0,s=t.additionalItems[m]||0;i.push(e|s)}return SmallImmutableSet.create(e,i)}intersects(t){if(0!==(this.items&t.items))return!0;for(let e=0;e<Math.min(this.additionalItems.length,t.additionalItems.length);e++)if(0!==(this.additionalItems[e]&t.additionalItems[e]))return!0;return!1}}SmallImmutableSet.cache=new Array(129),SmallImmutableSet.empty=SmallImmutableSet.create(0,emptyArr);export const identityKeyProvider={getKey(t){return t}};export class DenseKeyProvider{constructor(){this.items=new Map}getKey(t){let e=this.items.get(t);return void 0===e&&(e=this.items.size,this.items.set(t,e)),e}}