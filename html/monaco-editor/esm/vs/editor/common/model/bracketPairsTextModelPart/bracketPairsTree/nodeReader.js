import{lengthAdd,lengthZero,lengthLessThan}from"./length.js";export class NodeReader{constructor(t){this.lastOffset=lengthZero,this.nextNodes=[t],this.offsets=[lengthZero],this.idxs=[]}readLongestNodeAt(t,e){if(lengthLessThan(t,this.lastOffset))throw new Error("Invalid offset");this.lastOffset=t;while(1){const s=lastOrUndefined(this.nextNodes);if(!s)return;const h=lastOrUndefined(this.offsets);if(lengthLessThan(t,h))return;if(lengthLessThan(h,t))if(lengthAdd(h,s.length)<=t)this.nextNodeAfterCurrent();else{const t=getNextChildIdx(s);-1!==t?(this.nextNodes.push(s.getChild(t)),this.offsets.push(h),this.idxs.push(t)):this.nextNodeAfterCurrent()}else{if(e(s))return this.nextNodeAfterCurrent(),s;{const t=getNextChildIdx(s);if(-1===t)return void this.nextNodeAfterCurrent();this.nextNodes.push(s.getChild(t)),this.offsets.push(h),this.idxs.push(t)}}}}nextNodeAfterCurrent(){while(1){const t=lastOrUndefined(this.offsets),e=lastOrUndefined(this.nextNodes);if(this.nextNodes.pop(),this.offsets.pop(),0===this.idxs.length)break;const s=lastOrUndefined(this.nextNodes),h=getNextChildIdx(s,this.idxs[this.idxs.length-1]);if(-1!==h){this.nextNodes.push(s.getChild(h)),this.offsets.push(lengthAdd(t,e.length)),this.idxs[this.idxs.length-1]=h;break}this.idxs.pop()}}}function getNextChildIdx(t,e=-1){while(1){if(e++,e>=t.childrenLength)return-1;if(t.getChild(e))return e}}function lastOrUndefined(t){return t.length>0?t[t.length-1]:void 0}