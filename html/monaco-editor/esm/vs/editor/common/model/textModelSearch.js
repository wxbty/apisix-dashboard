import*as strings from"../../../base/common/strings.js";import{getMapForWordSeparators}from"../core/wordCharacterClassifier.js";import{Position}from"../core/position.js";import{Range}from"../core/range.js";import{FindMatch,SearchData}from"../model.js";const LIMIT_FIND_COUNT=999;export class SearchParams{constructor(e,t,n,i){this.searchString=e,this.isRegex=t,this.matchCase=n,this.wordSeparators=i}parseSearchRequest(){if(""===this.searchString)return null;let e;e=this.isRegex?isMultilineRegexSource(this.searchString):this.searchString.indexOf("\n")>=0;let t=null;try{t=strings.createRegExp(this.searchString,this.isRegex,{matchCase:this.matchCase,wholeWord:!1,multiline:e,global:!0,unicode:!0})}catch(i){return null}if(!t)return null;let n=!this.isRegex&&!e;return n&&this.searchString.toLowerCase()!==this.searchString.toUpperCase()&&(n=this.matchCase),new SearchData(t,this.wordSeparators?getMapForWordSeparators(this.wordSeparators):null,n?this.searchString:null)}}export function isMultilineRegexSource(e){if(!e||0===e.length)return!1;for(let t=0,n=e.length;t<n;t++){const i=e.charCodeAt(t);if(92===i){if(t++,t>=n)break;const i=e.charCodeAt(t);if(110===i||114===i||87===i)return!0}}return!1}export function createFindMatch(e,t,n){if(!n)return new FindMatch(e,null);const i=[];for(let r=0,s=t.length;r<s;r++)i[r]=t[r];return new FindMatch(e,i)}class LineFeedCounter{constructor(e){const t=[];let n=0;for(let i=0,r=e.length;i<r;i++)10===e.charCodeAt(i)&&(t[n++]=i);this._lineFeedsOffsets=t}findLineFeedCountBeforeOffset(e){const t=this._lineFeedsOffsets;let n=0,i=t.length-1;if(-1===i)return 0;if(e<=t[0])return 0;while(n<i){const r=n+((i-n)/2>>0);t[r]>=e?i=r-1:t[r+1]>=e?(n=r,i=r):n=r+1}return n+1}}export class TextModelSearch{static findMatches(e,t,n,i,r){const s=t.parseSearchRequest();return s?s.regex.multiline?this._doFindMatchesMultiline(e,n,new Searcher(s.wordSeparators,s.regex),i,r):this._doFindMatchesLineByLine(e,n,s,i,r):[]}static _getMultilineMatchRange(e,t,n,i,r,s){let a,o,c=0;if(i?(c=i.findLineFeedCountBeforeOffset(r),a=t+r+c):a=t+r,i){const e=i.findLineFeedCountBeforeOffset(r+s.length),t=e-c;o=a+s.length+t}else o=a+s.length;const h=e.getPositionAt(a),l=e.getPositionAt(o);return new Range(h.lineNumber,h.column,l.lineNumber,l.column)}static _doFindMatchesMultiline(e,t,n,i,r){const s=e.getOffsetAt(t.getStartPosition()),a=e.getValueInRange(t,1),o="\r\n"===e.getEOL()?new LineFeedCounter(a):null,c=[];let h,l=0;n.reset(0);while(h=n.next(a))if(c[l++]=createFindMatch(this._getMultilineMatchRange(e,s,a,o,h.index,h[0]),h,i),l>=r)return c;return c}static _doFindMatchesLineByLine(e,t,n,i,r){const s=[];let a=0;if(t.startLineNumber===t.endLineNumber){const o=e.getLineContent(t.startLineNumber).substring(t.startColumn-1,t.endColumn-1);return a=this._findMatchesInLine(n,o,t.startLineNumber,t.startColumn-1,a,s,i,r),s}const o=e.getLineContent(t.startLineNumber).substring(t.startColumn-1);a=this._findMatchesInLine(n,o,t.startLineNumber,t.startColumn-1,a,s,i,r);for(let c=t.startLineNumber+1;c<t.endLineNumber&&a<r;c++)a=this._findMatchesInLine(n,e.getLineContent(c),c,0,a,s,i,r);if(a<r){const o=e.getLineContent(t.endLineNumber).substring(0,t.endColumn-1);a=this._findMatchesInLine(n,o,t.endLineNumber,0,a,s,i,r)}return s}static _findMatchesInLine(e,t,n,i,r,s,a,o){const c=e.wordSeparators;if(!a&&e.simpleSearch){const a=e.simpleSearch,h=a.length,l=t.length;let u=-h;while(-1!==(u=t.indexOf(a,u+h)))if((!c||isValidMatch(c,t,l,u,h))&&(s[r++]=new FindMatch(new Range(n,u+1+i,n,u+1+h+i),null),r>=o))return r;return r}const h=new Searcher(e.wordSeparators,e.regex);let l;h.reset(0);do{if(l=h.next(t),l&&(s[r++]=createFindMatch(new Range(n,l.index+1+i,n,l.index+1+l[0].length+i),l,a),r>=o))return r}while(l);return r}static findNextMatch(e,t,n,i){const r=t.parseSearchRequest();if(!r)return null;const s=new Searcher(r.wordSeparators,r.regex);return r.regex.multiline?this._doFindNextMatchMultiline(e,n,s,i):this._doFindNextMatchLineByLine(e,n,s,i)}static _doFindNextMatchMultiline(e,t,n,i){const r=new Position(t.lineNumber,1),s=e.getOffsetAt(r),a=e.getLineCount(),o=e.getValueInRange(new Range(r.lineNumber,r.column,a,e.getLineMaxColumn(a)),1),c="\r\n"===e.getEOL()?new LineFeedCounter(o):null;n.reset(t.column-1);let h=n.next(o);return h?createFindMatch(this._getMultilineMatchRange(e,s,o,c,h.index,h[0]),h,i):1!==t.lineNumber||1!==t.column?this._doFindNextMatchMultiline(e,new Position(1,1),n,i):null}static _doFindNextMatchLineByLine(e,t,n,i){const r=e.getLineCount(),s=t.lineNumber,a=e.getLineContent(s),o=this._findFirstMatchInLine(n,a,s,t.column,i);if(o)return o;for(let c=1;c<=r;c++){const t=(s+c-1)%r,a=e.getLineContent(t+1),o=this._findFirstMatchInLine(n,a,t+1,1,i);if(o)return o}return null}static _findFirstMatchInLine(e,t,n,i,r){e.reset(i-1);const s=e.next(t);return s?createFindMatch(new Range(n,s.index+1,n,s.index+1+s[0].length),s,r):null}static findPreviousMatch(e,t,n,i){const r=t.parseSearchRequest();if(!r)return null;const s=new Searcher(r.wordSeparators,r.regex);return r.regex.multiline?this._doFindPreviousMatchMultiline(e,n,s,i):this._doFindPreviousMatchLineByLine(e,n,s,i)}static _doFindPreviousMatchMultiline(e,t,n,i){const r=this._doFindMatchesMultiline(e,new Range(1,1,t.lineNumber,t.column),n,i,10*LIMIT_FIND_COUNT);if(r.length>0)return r[r.length-1];const s=e.getLineCount();return t.lineNumber!==s||t.column!==e.getLineMaxColumn(s)?this._doFindPreviousMatchMultiline(e,new Position(s,e.getLineMaxColumn(s)),n,i):null}static _doFindPreviousMatchLineByLine(e,t,n,i){const r=e.getLineCount(),s=t.lineNumber,a=e.getLineContent(s).substring(0,t.column-1),o=this._findLastMatchInLine(n,a,s,i);if(o)return o;for(let c=1;c<=r;c++){const t=(r+s-c-1)%r,a=e.getLineContent(t+1),o=this._findLastMatchInLine(n,a,t+1,i);if(o)return o}return null}static _findLastMatchInLine(e,t,n,i){let r,s=null;e.reset(0);while(r=e.next(t))s=createFindMatch(new Range(n,r.index+1,n,r.index+1+r[0].length),r,i);return s}}function leftIsWordBounday(e,t,n,i,r){if(0===i)return!0;const s=t.charCodeAt(i-1);if(0!==e.get(s))return!0;if(13===s||10===s)return!0;if(r>0){const n=t.charCodeAt(i);if(0!==e.get(n))return!0}return!1}function rightIsWordBounday(e,t,n,i,r){if(i+r===n)return!0;const s=t.charCodeAt(i+r);if(0!==e.get(s))return!0;if(13===s||10===s)return!0;if(r>0){const n=t.charCodeAt(i+r-1);if(0!==e.get(n))return!0}return!1}export function isValidMatch(e,t,n,i,r){return leftIsWordBounday(e,t,n,i,r)&&rightIsWordBounday(e,t,n,i,r)}export class Searcher{constructor(e,t){this._wordSeparators=e,this._searchRegex=t,this._prevMatchStartIndex=-1,this._prevMatchLength=0}reset(e){this._searchRegex.lastIndex=e,this._prevMatchStartIndex=-1,this._prevMatchLength=0}next(e){const t=e.length;let n;do{if(this._prevMatchStartIndex+this._prevMatchLength===t)return null;if(n=this._searchRegex.exec(e),!n)return null;const i=n.index,r=n[0].length;if(i===this._prevMatchStartIndex&&r===this._prevMatchLength){if(0===r){strings.getNextCodePoint(e,t,this._searchRegex.lastIndex)>65535?this._searchRegex.lastIndex+=2:this._searchRegex.lastIndex+=1;continue}return null}if(this._prevMatchStartIndex=i,this._prevMatchLength=r,!this._wordSeparators||isValidMatch(this._wordSeparators,e,t,i,r))return n}while(n);return null}}