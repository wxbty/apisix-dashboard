export function getNodeColor(t){return(1&t.metadata)>>>0}function setNodeColor(t,e){t.metadata=254&t.metadata|e<<0}function getNodeIsVisited(t){return(2&t.metadata)>>>1===1}function setNodeIsVisited(t,e){t.metadata=253&t.metadata|(e?1:0)<<1}function getNodeIsForValidation(t){return(4&t.metadata)>>>2===1}function setNodeIsForValidation(t,e){t.metadata=251&t.metadata|(e?1:0)<<2}function getNodeStickiness(t){return(24&t.metadata)>>>3}function _setNodeStickiness(t,e){t.metadata=231&t.metadata|e<<3}function getCollapseOnReplaceEdit(t){return(32&t.metadata)>>>5===1}function setCollapseOnReplaceEdit(t,e){t.metadata=223&t.metadata|(e?1:0)<<5}export class IntervalNode{constructor(t,e,o){this.metadata=0,this.parent=this,this.left=this,this.right=this,setNodeColor(this,1),this.start=e,this.end=o,this.delta=0,this.maxEnd=o,this.id=t,this.ownerId=0,this.options=null,setNodeIsForValidation(this,!1),_setNodeStickiness(this,1),setCollapseOnReplaceEdit(this,!1),this.cachedVersionId=0,this.cachedAbsoluteStart=e,this.cachedAbsoluteEnd=o,this.range=null,setNodeIsVisited(this,!1)}reset(t,e,o,r){this.start=e,this.end=o,this.maxEnd=o,this.cachedVersionId=t,this.cachedAbsoluteStart=e,this.cachedAbsoluteEnd=o,this.range=r}setOptions(t){this.options=t;const e=this.options.className;setNodeIsForValidation(this,"squiggly-error"===e||"squiggly-warning"===e||"squiggly-info"===e),_setNodeStickiness(this,this.options.stickiness),setCollapseOnReplaceEdit(this,this.options.collapseOnReplaceEdit)}setCachedOffsets(t,e,o){this.cachedVersionId!==o&&(this.range=null),this.cachedVersionId=o,this.cachedAbsoluteStart=t,this.cachedAbsoluteEnd=e}detach(){this.parent=null,this.left=null,this.right=null}}export const SENTINEL=new IntervalNode(null,0,0);SENTINEL.parent=SENTINEL,SENTINEL.left=SENTINEL,SENTINEL.right=SENTINEL,setNodeColor(SENTINEL,0);export class IntervalTree{constructor(){this.root=SENTINEL,this.requestNormalizeDelta=!1}intervalSearch(t,e,o,r,s){return this.root===SENTINEL?[]:intervalSearch(this,t,e,o,r,s)}search(t,e,o){return this.root===SENTINEL?[]:search(this,t,e,o)}collectNodesFromOwner(t){return collectNodesFromOwner(this,t)}collectNodesPostOrder(){return collectNodesPostOrder(this)}insert(t){rbTreeInsert(this,t),this._normalizeDeltaIfNecessary()}delete(t){rbTreeDelete(this,t),this._normalizeDeltaIfNecessary()}resolveNode(t,e){const o=t;let r=0;while(t!==this.root)t===t.parent.right&&(r+=t.parent.delta),t=t.parent;const s=o.start+r,a=o.end+r;o.setCachedOffsets(s,a,e)}acceptReplace(t,e,o,r){const s=searchForEditing(this,t,t+e);for(let a=0,i=s.length;a<i;a++){const t=s[a];rbTreeDelete(this,t)}this._normalizeDeltaIfNecessary(),noOverlapReplace(this,t,t+e,o),this._normalizeDeltaIfNecessary();for(let a=0,i=s.length;a<i;a++){const i=s[a];i.start=i.cachedAbsoluteStart,i.end=i.cachedAbsoluteEnd,nodeAcceptEdit(i,t,t+e,o,r),i.maxEnd=i.end,rbTreeInsert(this,i)}this._normalizeDeltaIfNecessary()}_normalizeDeltaIfNecessary(){this.requestNormalizeDelta&&(this.requestNormalizeDelta=!1,normalizeDelta(this))}}function normalizeDelta(t){let e=t.root,o=0;while(e!==SENTINEL)e.left===SENTINEL||getNodeIsVisited(e.left)?e.right===SENTINEL||getNodeIsVisited(e.right)?(e.start=o+e.start,e.end=o+e.end,e.delta=0,recomputeMaxEnd(e),setNodeIsVisited(e,!0),setNodeIsVisited(e.left,!1),setNodeIsVisited(e.right,!1),e===e.parent.right&&(o-=e.parent.delta),e=e.parent):(o+=e.delta,e=e.right):e=e.left;setNodeIsVisited(t.root,!1)}function adjustMarkerBeforeColumn(t,e,o,r){return t<o||!(t>o)&&(1!==r&&(2===r||e))}export function nodeAcceptEdit(t,e,o,r,s){const a=getNodeStickiness(t),i=0===a||2===a,n=1===a||2===a,d=o-e,l=r,N=Math.min(d,l),h=t.start;let c=!1;const p=t.end;let E=!1;e<=h&&p<=o&&getCollapseOnReplaceEdit(t)&&(t.start=e,c=!0,t.end=e,E=!0);{const t=s?1:d>0?2:0;!c&&adjustMarkerBeforeColumn(h,i,e,t)&&(c=!0),!E&&adjustMarkerBeforeColumn(p,n,e,t)&&(E=!0)}if(N>0&&!s){const t=d>l?2:0;!c&&adjustMarkerBeforeColumn(h,i,e+N,t)&&(c=!0),!E&&adjustMarkerBeforeColumn(p,n,e+N,t)&&(E=!0)}{const r=s?1:0;!c&&adjustMarkerBeforeColumn(h,i,o,r)&&(t.start=e+l,c=!0),!E&&adjustMarkerBeforeColumn(p,n,o,r)&&(t.end=e+l,E=!0)}const f=l-d;c||(t.start=Math.max(0,h+f)),E||(t.end=Math.max(0,p+f)),t.start>t.end&&(t.end=t.start)}function searchForEditing(t,e,o){let r=t.root,s=0,a=0,i=0,n=0;const d=[];let l=0;while(r!==SENTINEL)if(getNodeIsVisited(r))setNodeIsVisited(r.left,!1),setNodeIsVisited(r.right,!1),r===r.parent.right&&(s-=r.parent.delta),r=r.parent;else{if(!getNodeIsVisited(r.left)){if(a=s+r.maxEnd,a<e){setNodeIsVisited(r,!0);continue}if(r.left!==SENTINEL){r=r.left;continue}}i=s+r.start,i>o?setNodeIsVisited(r,!0):(n=s+r.end,n>=e&&(r.setCachedOffsets(i,n,0),d[l++]=r),setNodeIsVisited(r,!0),r.right===SENTINEL||getNodeIsVisited(r.right)||(s+=r.delta,r=r.right))}return setNodeIsVisited(t.root,!1),d}function noOverlapReplace(t,e,o,r){let s=t.root,a=0,i=0,n=0;const d=r-(o-e);while(s!==SENTINEL)if(getNodeIsVisited(s))setNodeIsVisited(s.left,!1),setNodeIsVisited(s.right,!1),s===s.parent.right&&(a-=s.parent.delta),recomputeMaxEnd(s),s=s.parent;else{if(!getNodeIsVisited(s.left)){if(i=a+s.maxEnd,i<e){setNodeIsVisited(s,!0);continue}if(s.left!==SENTINEL){s=s.left;continue}}n=a+s.start,n>o?(s.start+=d,s.end+=d,s.delta+=d,(s.delta<-1073741824||s.delta>1073741824)&&(t.requestNormalizeDelta=!0),setNodeIsVisited(s,!0)):(setNodeIsVisited(s,!0),s.right===SENTINEL||getNodeIsVisited(s.right)||(a+=s.delta,s=s.right))}setNodeIsVisited(t.root,!1)}function collectNodesFromOwner(t,e){let o=t.root;const r=[];let s=0;while(o!==SENTINEL)getNodeIsVisited(o)?(setNodeIsVisited(o.left,!1),setNodeIsVisited(o.right,!1),o=o.parent):o.left===SENTINEL||getNodeIsVisited(o.left)?(o.ownerId===e&&(r[s++]=o),setNodeIsVisited(o,!0),o.right===SENTINEL||getNodeIsVisited(o.right)||(o=o.right)):o=o.left;return setNodeIsVisited(t.root,!1),r}function collectNodesPostOrder(t){let e=t.root;const o=[];let r=0;while(e!==SENTINEL)getNodeIsVisited(e)?(setNodeIsVisited(e.left,!1),setNodeIsVisited(e.right,!1),e=e.parent):e.left===SENTINEL||getNodeIsVisited(e.left)?e.right===SENTINEL||getNodeIsVisited(e.right)?(o[r++]=e,setNodeIsVisited(e,!0)):e=e.right:e=e.left;return setNodeIsVisited(t.root,!1),o}function search(t,e,o,r){let s=t.root,a=0,i=0,n=0;const d=[];let l=0;while(s!==SENTINEL){if(getNodeIsVisited(s)){setNodeIsVisited(s.left,!1),setNodeIsVisited(s.right,!1),s===s.parent.right&&(a-=s.parent.delta),s=s.parent;continue}if(s.left!==SENTINEL&&!getNodeIsVisited(s.left)){s=s.left;continue}i=a+s.start,n=a+s.end,s.setCachedOffsets(i,n,r);let t=!0;e&&s.ownerId&&s.ownerId!==e&&(t=!1),o&&getNodeIsForValidation(s)&&(t=!1),t&&(d[l++]=s),setNodeIsVisited(s,!0),s.right===SENTINEL||getNodeIsVisited(s.right)||(a+=s.delta,s=s.right)}return setNodeIsVisited(t.root,!1),d}function intervalSearch(t,e,o,r,s,a){let i=t.root,n=0,d=0,l=0,N=0;const h=[];let c=0;while(i!==SENTINEL)if(getNodeIsVisited(i))setNodeIsVisited(i.left,!1),setNodeIsVisited(i.right,!1),i===i.parent.right&&(n-=i.parent.delta),i=i.parent;else{if(!getNodeIsVisited(i.left)){if(d=n+i.maxEnd,d<e){setNodeIsVisited(i,!0);continue}if(i.left!==SENTINEL){i=i.left;continue}}if(l=n+i.start,l>o)setNodeIsVisited(i,!0);else{if(N=n+i.end,N>=e){i.setCachedOffsets(l,N,a);let t=!0;r&&i.ownerId&&i.ownerId!==r&&(t=!1),s&&getNodeIsForValidation(i)&&(t=!1),t&&(h[c++]=i)}setNodeIsVisited(i,!0),i.right===SENTINEL||getNodeIsVisited(i.right)||(n+=i.delta,i=i.right)}}return setNodeIsVisited(t.root,!1),h}function rbTreeInsert(t,e){if(t.root===SENTINEL)return e.parent=SENTINEL,e.left=SENTINEL,e.right=SENTINEL,setNodeColor(e,0),t.root=e,t.root;treeInsert(t,e),recomputeMaxEndWalkToRoot(e.parent);let o=e;while(o!==t.root&&1===getNodeColor(o.parent))if(o.parent===o.parent.parent.left){const e=o.parent.parent.right;1===getNodeColor(e)?(setNodeColor(o.parent,0),setNodeColor(e,0),setNodeColor(o.parent.parent,1),o=o.parent.parent):(o===o.parent.right&&(o=o.parent,leftRotate(t,o)),setNodeColor(o.parent,0),setNodeColor(o.parent.parent,1),rightRotate(t,o.parent.parent))}else{const e=o.parent.parent.left;1===getNodeColor(e)?(setNodeColor(o.parent,0),setNodeColor(e,0),setNodeColor(o.parent.parent,1),o=o.parent.parent):(o===o.parent.left&&(o=o.parent,rightRotate(t,o)),setNodeColor(o.parent,0),setNodeColor(o.parent.parent,1),leftRotate(t,o.parent.parent))}return setNodeColor(t.root,0),e}function treeInsert(t,e){let o=0,r=t.root;const s=e.start,a=e.end;while(1){const t=intervalCompare(s,a,r.start+o,r.end+o);if(t<0){if(r.left===SENTINEL){e.start-=o,e.end-=o,e.maxEnd-=o,r.left=e;break}r=r.left}else{if(r.right===SENTINEL){e.start-=o+r.delta,e.end-=o+r.delta,e.maxEnd-=o+r.delta,r.right=e;break}o+=r.delta,r=r.right}}e.parent=r,e.left=SENTINEL,e.right=SENTINEL,setNodeColor(e,1)}function rbTreeDelete(t,e){let o,r;if(e.left===SENTINEL?(o=e.right,r=e,o.delta+=e.delta,(o.delta<-1073741824||o.delta>1073741824)&&(t.requestNormalizeDelta=!0),o.start+=e.delta,o.end+=e.delta):e.right===SENTINEL?(o=e.left,r=e):(r=leftest(e.right),o=r.right,o.start+=r.delta,o.end+=r.delta,o.delta+=r.delta,(o.delta<-1073741824||o.delta>1073741824)&&(t.requestNormalizeDelta=!0),r.start+=e.delta,r.end+=e.delta,r.delta=e.delta,(r.delta<-1073741824||r.delta>1073741824)&&(t.requestNormalizeDelta=!0)),r===t.root)return t.root=o,setNodeColor(o,0),e.detach(),resetSentinel(),recomputeMaxEnd(o),void(t.root.parent=SENTINEL);const s=1===getNodeColor(r);if(r===r.parent.left?r.parent.left=o:r.parent.right=o,r===e?o.parent=r.parent:(r.parent===e?o.parent=r:o.parent=r.parent,r.left=e.left,r.right=e.right,r.parent=e.parent,setNodeColor(r,getNodeColor(e)),e===t.root?t.root=r:e===e.parent.left?e.parent.left=r:e.parent.right=r,r.left!==SENTINEL&&(r.left.parent=r),r.right!==SENTINEL&&(r.right.parent=r)),e.detach(),s)return recomputeMaxEndWalkToRoot(o.parent),r!==e&&(recomputeMaxEndWalkToRoot(r),recomputeMaxEndWalkToRoot(r.parent)),void resetSentinel();let a;recomputeMaxEndWalkToRoot(o),recomputeMaxEndWalkToRoot(o.parent),r!==e&&(recomputeMaxEndWalkToRoot(r),recomputeMaxEndWalkToRoot(r.parent));while(o!==t.root&&0===getNodeColor(o))o===o.parent.left?(a=o.parent.right,1===getNodeColor(a)&&(setNodeColor(a,0),setNodeColor(o.parent,1),leftRotate(t,o.parent),a=o.parent.right),0===getNodeColor(a.left)&&0===getNodeColor(a.right)?(setNodeColor(a,1),o=o.parent):(0===getNodeColor(a.right)&&(setNodeColor(a.left,0),setNodeColor(a,1),rightRotate(t,a),a=o.parent.right),setNodeColor(a,getNodeColor(o.parent)),setNodeColor(o.parent,0),setNodeColor(a.right,0),leftRotate(t,o.parent),o=t.root)):(a=o.parent.left,1===getNodeColor(a)&&(setNodeColor(a,0),setNodeColor(o.parent,1),rightRotate(t,o.parent),a=o.parent.left),0===getNodeColor(a.left)&&0===getNodeColor(a.right)?(setNodeColor(a,1),o=o.parent):(0===getNodeColor(a.left)&&(setNodeColor(a.right,0),setNodeColor(a,1),leftRotate(t,a),a=o.parent.left),setNodeColor(a,getNodeColor(o.parent)),setNodeColor(o.parent,0),setNodeColor(a.left,0),rightRotate(t,o.parent),o=t.root));setNodeColor(o,0),resetSentinel()}function leftest(t){while(t.left!==SENTINEL)t=t.left;return t}function resetSentinel(){SENTINEL.parent=SENTINEL,SENTINEL.delta=0,SENTINEL.start=0,SENTINEL.end=0}function leftRotate(t,e){const o=e.right;o.delta+=e.delta,(o.delta<-1073741824||o.delta>1073741824)&&(t.requestNormalizeDelta=!0),o.start+=e.delta,o.end+=e.delta,e.right=o.left,o.left!==SENTINEL&&(o.left.parent=e),o.parent=e.parent,e.parent===SENTINEL?t.root=o:e===e.parent.left?e.parent.left=o:e.parent.right=o,o.left=e,e.parent=o,recomputeMaxEnd(e),recomputeMaxEnd(o)}function rightRotate(t,e){const o=e.left;e.delta-=o.delta,(e.delta<-1073741824||e.delta>1073741824)&&(t.requestNormalizeDelta=!0),e.start-=o.delta,e.end-=o.delta,e.left=o.right,o.right!==SENTINEL&&(o.right.parent=e),o.parent=e.parent,e.parent===SENTINEL?t.root=o:e===e.parent.right?e.parent.right=o:e.parent.left=o,o.right=e,e.parent=o,recomputeMaxEnd(e),recomputeMaxEnd(o)}function computeMaxEnd(t){let e=t.end;if(t.left!==SENTINEL){const o=t.left.maxEnd;o>e&&(e=o)}if(t.right!==SENTINEL){const o=t.right.maxEnd+t.delta;o>e&&(e=o)}return e}export function recomputeMaxEnd(t){t.maxEnd=computeMaxEnd(t)}function recomputeMaxEndWalkToRoot(t){while(t!==SENTINEL){const e=computeMaxEnd(t);if(t.maxEnd===e)return;t.maxEnd=e,t=t.parent}}export function intervalCompare(t,e,o,r){return t===o?e-r:t-o}