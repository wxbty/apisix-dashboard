import*as strings from"../../../base/common/strings.js";import{ReplaceCommand}from"../commands/replaceCommand.js";import{EditOperationResult,isQuote}from"./cursorCommon.js";import{CursorColumns}from"../core/cursorColumns.js";import{MoveOperations}from"./cursorMoveOperations.js";import{Range}from"../core/range.js";import{Position}from"../core/position.js";export class DeleteOperations{static deleteRight(e,t,n,o){const i=[];let r=3!==e;for(let l=0,s=o.length;l<s;l++){const e=o[l];let s=e;if(s.isEmpty()){const o=e.getPosition(),i=MoveOperations.right(t,n,o);s=new Range(i.lineNumber,i.column,o.lineNumber,o.column)}s.isEmpty()?i[l]=null:(s.startLineNumber!==s.endLineNumber&&(r=!0),i[l]=new ReplaceCommand(s,""))}return[r,i]}static isAutoClosingPairDelete(e,t,n,o,i,r,l){if("never"===t&&"never"===n)return!1;if("never"===e)return!1;for(let s=0,u=r.length;s<u;s++){const u=r[s],m=u.getPosition();if(!u.isEmpty())return!1;const a=i.getLineContent(m.lineNumber);if(m.column<2||m.column>=a.length+1)return!1;const c=a.charAt(m.column-2),g=o.get(c);if(!g)return!1;if(isQuote(c)){if("never"===n)return!1}else if("never"===t)return!1;const f=a.charAt(m.column-1);let p=!1;for(const e of g)e.open===c&&e.close===f&&(p=!0);if(!p)return!1;if("auto"===e){let e=!1;for(let t=0,n=l.length;t<n;t++){const n=l[t];if(m.lineNumber===n.startLineNumber&&m.column===n.startColumn){e=!0;break}}if(!e)return!1}}return!0}static _runAutoClosingPairDelete(e,t,n){const o=[];for(let i=0,r=n.length;i<r;i++){const e=n[i].getPosition(),t=new Range(e.lineNumber,e.column-1,e.lineNumber,e.column+1);o[i]=new ReplaceCommand(t,"")}return[!0,o]}static deleteLeft(e,t,n,o,i){if(this.isAutoClosingPairDelete(t.autoClosingDelete,t.autoClosingBrackets,t.autoClosingQuotes,t.autoClosingPairs.autoClosingPairsOpenByEnd,n,o,i))return this._runAutoClosingPairDelete(t,n,o);const r=[];let l=2!==e;for(let s=0,u=o.length;s<u;s++){const e=DeleteOperations.getDeleteRange(o[s],n,t);e.isEmpty()?r[s]=null:(e.startLineNumber!==e.endLineNumber&&(l=!0),r[s]=new ReplaceCommand(e,""))}return[l,r]}static getDeleteRange(e,t,n){if(!e.isEmpty())return e;const o=e.getPosition();if(n.useTabStops&&o.column>1){const e=t.getLineContent(o.lineNumber),i=strings.firstNonWhitespaceIndex(e),r=-1===i?e.length+1:i+1;if(o.column<=r){const e=n.visibleColumnFromColumn(t,o),i=CursorColumns.prevIndentTabStop(e,n.indentSize),r=n.columnFromVisibleColumn(t,o.lineNumber,i);return new Range(o.lineNumber,r,o.lineNumber,o.column)}}return Range.fromPositions(DeleteOperations.getPositionAfterDeleteLeft(o,t),o)}static getPositionAfterDeleteLeft(e,t){if(e.column>1){const n=strings.getLeftDeleteOffset(e.column-1,t.getLineContent(e.lineNumber));return e.with(void 0,n+1)}if(e.lineNumber>1){const n=e.lineNumber-1;return new Position(n,t.getLineMaxColumn(n))}return e}static cut(e,t,n){const o=[];let i=null;n.sort(((e,t)=>Position.compare(e.getStartPosition(),t.getEndPosition())));for(let r=0,l=n.length;r<l;r++){const l=n[r];if(l.isEmpty())if(e.emptySelectionClipboard){const e=l.getPosition();let n,s,u,m;e.lineNumber<t.getLineCount()?(n=e.lineNumber,s=1,u=e.lineNumber+1,m=1):e.lineNumber>1&&(null===i||void 0===i?void 0:i.endLineNumber)!==e.lineNumber?(n=e.lineNumber-1,s=t.getLineMaxColumn(e.lineNumber-1),u=e.lineNumber,m=t.getLineMaxColumn(e.lineNumber)):(n=e.lineNumber,s=1,u=e.lineNumber,m=t.getLineMaxColumn(e.lineNumber));const a=new Range(n,s,u,m);i=a,a.isEmpty()?o[r]=null:o[r]=new ReplaceCommand(a,"")}else o[r]=null;else o[r]=new ReplaceCommand(l,"")}return new EditOperationResult(0,o,{shouldPushStackElementBefore:!0,shouldPushStackElementAfter:!0})}}