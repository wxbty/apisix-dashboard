import{SingleCursorState}from"./cursorCommon.js";import{CursorColumns}from"../core/cursorColumns.js";import{Position}from"../core/position.js";import{Range}from"../core/range.js";import*as strings from"../../../base/common/strings.js";import{AtomicTabMoveOperations}from"./cursorAtomicMoveOperations.js";export class CursorPosition{constructor(e,n,i){this._cursorPositionBrand=void 0,this.lineNumber=e,this.column=n,this.leftoverVisibleColumns=i}}export class MoveOperations{static leftPosition(e,n){if(n.column>e.getLineMinColumn(n.lineNumber))return n.delta(void 0,-strings.prevCharLength(e.getLineContent(n.lineNumber),n.column-1));if(n.lineNumber>1){const i=n.lineNumber-1;return new Position(i,e.getLineMaxColumn(i))}return n}static leftPositionAtomicSoftTabs(e,n,i){if(n.column<=e.getLineIndentColumn(n.lineNumber)){const o=e.getLineMinColumn(n.lineNumber),t=e.getLineContent(n.lineNumber),s=AtomicTabMoveOperations.atomicPosition(t,n.column-1,i,0);if(-1!==s&&s+1>=o)return new Position(n.lineNumber,s+1)}return this.leftPosition(e,n)}static left(e,n,i){const o=e.stickyTabStops?MoveOperations.leftPositionAtomicSoftTabs(n,i,e.tabSize):MoveOperations.leftPosition(n,i);return new CursorPosition(o.lineNumber,o.column,0)}static moveLeft(e,n,i,o,t){let s,r;if(i.hasSelection()&&!o)s=i.selection.startLineNumber,r=i.selection.startColumn;else{const o=i.position.delta(void 0,-(t-1)),l=n.normalizePosition(MoveOperations.clipPositionColumn(o,n),0),m=MoveOperations.left(e,n,l);s=m.lineNumber,r=m.column}return i.move(o,s,r,0)}static clipPositionColumn(e,n){return new Position(e.lineNumber,MoveOperations.clipRange(e.column,n.getLineMinColumn(e.lineNumber),n.getLineMaxColumn(e.lineNumber)))}static clipRange(e,n,i){return e<n?n:e>i?i:e}static rightPosition(e,n,i){return i<e.getLineMaxColumn(n)?i+=strings.nextCharLength(e.getLineContent(n),i-1):n<e.getLineCount()&&(n+=1,i=e.getLineMinColumn(n)),new Position(n,i)}static rightPositionAtomicSoftTabs(e,n,i,o,t){if(i<e.getLineIndentColumn(n)){const t=e.getLineContent(n),s=AtomicTabMoveOperations.atomicPosition(t,i-1,o,1);if(-1!==s)return new Position(n,s+1)}return this.rightPosition(e,n,i)}static right(e,n,i){const o=e.stickyTabStops?MoveOperations.rightPositionAtomicSoftTabs(n,i.lineNumber,i.column,e.tabSize,e.indentSize):MoveOperations.rightPosition(n,i.lineNumber,i.column);return new CursorPosition(o.lineNumber,o.column,0)}static moveRight(e,n,i,o,t){let s,r;if(i.hasSelection()&&!o)s=i.selection.endLineNumber,r=i.selection.endColumn;else{const o=i.position.delta(void 0,t-1),l=n.normalizePosition(MoveOperations.clipPositionColumn(o,n),1),m=MoveOperations.right(e,n,l);s=m.lineNumber,r=m.column}return i.move(o,s,r,0)}static vertical(e,n,i,o,t,s,r,l){const m=CursorColumns.visibleColumnFromColumn(n.getLineContent(i),o,e.tabSize)+t,u=n.getLineCount(),a=1===i&&1===o,c=i===u&&o===n.getLineMaxColumn(i),C=s<i?a:c;if(i=s,i<1?(i=1,o=r?n.getLineMinColumn(i):Math.min(n.getLineMaxColumn(i),o)):i>u?(i=u,o=r?n.getLineMaxColumn(i):Math.min(n.getLineMaxColumn(i),o)):o=e.columnFromVisibleColumn(n,i,m),t=C?0:m-CursorColumns.visibleColumnFromColumn(n.getLineContent(i),o,e.tabSize),void 0!==l){const e=new Position(i,o),s=n.normalizePosition(e,l);t+=o-s.column,i=s.lineNumber,o=s.column}return new CursorPosition(i,o,t)}static down(e,n,i,o,t,s,r){return this.vertical(e,n,i,o,t,i+s,r,1)}static moveDown(e,n,i,o,t){let s,r;i.hasSelection()&&!o?(s=i.selection.endLineNumber,r=i.selection.endColumn):(s=i.position.lineNumber,r=i.position.column);const l=MoveOperations.down(e,n,s,r,i.leftoverVisibleColumns,t,!0);return i.move(o,l.lineNumber,l.column,l.leftoverVisibleColumns)}static translateDown(e,n,i){const o=i.selection,t=MoveOperations.down(e,n,o.selectionStartLineNumber,o.selectionStartColumn,i.selectionStartLeftoverVisibleColumns,1,!1),s=MoveOperations.down(e,n,o.positionLineNumber,o.positionColumn,i.leftoverVisibleColumns,1,!1);return new SingleCursorState(new Range(t.lineNumber,t.column,t.lineNumber,t.column),t.leftoverVisibleColumns,new Position(s.lineNumber,s.column),s.leftoverVisibleColumns)}static up(e,n,i,o,t,s,r){return this.vertical(e,n,i,o,t,i-s,r,0)}static moveUp(e,n,i,o,t){let s,r;i.hasSelection()&&!o?(s=i.selection.startLineNumber,r=i.selection.startColumn):(s=i.position.lineNumber,r=i.position.column);const l=MoveOperations.up(e,n,s,r,i.leftoverVisibleColumns,t,!0);return i.move(o,l.lineNumber,l.column,l.leftoverVisibleColumns)}static translateUp(e,n,i){const o=i.selection,t=MoveOperations.up(e,n,o.selectionStartLineNumber,o.selectionStartColumn,i.selectionStartLeftoverVisibleColumns,1,!1),s=MoveOperations.up(e,n,o.positionLineNumber,o.positionColumn,i.leftoverVisibleColumns,1,!1);return new SingleCursorState(new Range(t.lineNumber,t.column,t.lineNumber,t.column),t.leftoverVisibleColumns,new Position(s.lineNumber,s.column),s.leftoverVisibleColumns)}static _isBlankLine(e,n){return 0===e.getLineFirstNonWhitespaceColumn(n)}static moveToPrevBlankLine(e,n,i,o){let t=i.position.lineNumber;while(t>1&&this._isBlankLine(n,t))t--;while(t>1&&!this._isBlankLine(n,t))t--;return i.move(o,t,n.getLineMinColumn(t),0)}static moveToNextBlankLine(e,n,i,o){const t=n.getLineCount();let s=i.position.lineNumber;while(s<t&&this._isBlankLine(n,s))s++;while(s<t&&!this._isBlankLine(n,s))s++;return i.move(o,s,n.getLineMinColumn(s),0)}static moveToBeginningOfLine(e,n,i,o){const t=i.position.lineNumber,s=n.getLineMinColumn(t),r=n.getLineFirstNonWhitespaceColumn(t)||s;let l;const m=i.position.column;return l=m===r?s:r,i.move(o,t,l,0)}static moveToEndOfLine(e,n,i,o,t){const s=i.position.lineNumber,r=n.getLineMaxColumn(s);return i.move(o,s,r,t?1073741824-r:0)}static moveToBeginningOfBuffer(e,n,i,o){return i.move(o,1,1,0)}static moveToEndOfBuffer(e,n,i,o){const t=n.getLineCount(),s=n.getLineMaxColumn(t);return i.move(o,t,s,0)}}