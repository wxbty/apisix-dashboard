import*as types from"../../../base/common/types.js";import{CursorState,SingleCursorState}from"./cursorCommon.js";import{MoveOperations}from"./cursorMoveOperations.js";import{WordOperations}from"./cursorWordOperations.js";import{Position}from"../core/position.js";import{Range}from"../core/range.js";export class CursorMoveCommands{static addCursorDown(e,t,o){const n=[];let i=0;for(let r=0,a=t.length;r<a;r++){const a=t[r];n[i++]=new CursorState(a.modelState,a.viewState),n[i++]=o?CursorState.fromModelState(MoveOperations.translateDown(e.cursorConfig,e.model,a.modelState)):CursorState.fromViewState(MoveOperations.translateDown(e.cursorConfig,e,a.viewState))}return n}static addCursorUp(e,t,o){const n=[];let i=0;for(let r=0,a=t.length;r<a;r++){const a=t[r];n[i++]=new CursorState(a.modelState,a.viewState),n[i++]=o?CursorState.fromModelState(MoveOperations.translateUp(e.cursorConfig,e.model,a.modelState)):CursorState.fromViewState(MoveOperations.translateUp(e.cursorConfig,e,a.viewState))}return n}static moveToBeginningOfLine(e,t,o){let n=[];for(let i=0,r=t.length;i<r;i++){const r=t[i];n[i]=this._moveToLineStart(e,r,o)}return n}static _moveToLineStart(e,t,o){const n=t.viewState.position.column,i=t.modelState.position.column,r=n===i,a=t.viewState.position.lineNumber,s=e.getLineFirstNonWhitespaceColumn(a),l=n===s;return r||l?this._moveToLineStartByModel(e,t,o):this._moveToLineStartByView(e,t,o)}static _moveToLineStartByView(e,t,o){return CursorState.fromViewState(MoveOperations.moveToBeginningOfLine(e.cursorConfig,e,t.viewState,o))}static _moveToLineStartByModel(e,t,o){return CursorState.fromModelState(MoveOperations.moveToBeginningOfLine(e.cursorConfig,e.model,t.modelState,o))}static moveToEndOfLine(e,t,o,n){const i=[];for(let r=0,a=t.length;r<a;r++){const a=t[r];i[r]=this._moveToLineEnd(e,a,o,n)}return i}static _moveToLineEnd(e,t,o,n){const i=t.viewState.position,r=e.getLineMaxColumn(i.lineNumber),a=i.column===r,s=t.modelState.position,l=e.model.getLineMaxColumn(s.lineNumber),m=r-i.column===l-s.column;return a||m?this._moveToLineEndByModel(e,t,o,n):this._moveToLineEndByView(e,t,o,n)}static _moveToLineEndByView(e,t,o,n){return CursorState.fromViewState(MoveOperations.moveToEndOfLine(e.cursorConfig,e,t.viewState,o,n))}static _moveToLineEndByModel(e,t,o,n){return CursorState.fromModelState(MoveOperations.moveToEndOfLine(e.cursorConfig,e.model,t.modelState,o,n))}static expandLineSelection(e,t){const o=[];for(let n=0,i=t.length;n<i;n++){const i=t[n],r=i.modelState.selection.startLineNumber,a=e.model.getLineCount();let s,l=i.modelState.selection.endLineNumber;l===a?s=e.model.getLineMaxColumn(a):(l++,s=1),o[n]=CursorState.fromModelState(new SingleCursorState(new Range(r,1,r,1),0,new Position(l,s),0))}return o}static moveToBeginningOfBuffer(e,t,o){const n=[];for(let i=0,r=t.length;i<r;i++){const r=t[i];n[i]=CursorState.fromModelState(MoveOperations.moveToBeginningOfBuffer(e.cursorConfig,e.model,r.modelState,o))}return n}static moveToEndOfBuffer(e,t,o){const n=[];for(let i=0,r=t.length;i<r;i++){const r=t[i];n[i]=CursorState.fromModelState(MoveOperations.moveToEndOfBuffer(e.cursorConfig,e.model,r.modelState,o))}return n}static selectAll(e,t){const o=e.model.getLineCount(),n=e.model.getLineMaxColumn(o);return CursorState.fromModelState(new SingleCursorState(new Range(1,1,1,1),0,new Position(o,n),0))}static line(e,t,o,n,i){const r=e.model.validatePosition(n),a=i?e.coordinatesConverter.validateViewPosition(new Position(i.lineNumber,i.column),r):e.coordinatesConverter.convertModelPositionToViewPosition(r);if(!o||!t.modelState.hasSelection()){const t=e.model.getLineCount();let o=r.lineNumber+1,n=1;return o>t&&(o=t,n=e.model.getLineMaxColumn(o)),CursorState.fromModelState(new SingleCursorState(new Range(r.lineNumber,1,o,n),0,new Position(o,n),0))}const s=t.modelState.selectionStart.getStartPosition().lineNumber;if(r.lineNumber<s)return CursorState.fromViewState(t.viewState.move(t.modelState.hasSelection(),a.lineNumber,1,0));if(r.lineNumber>s){const o=e.getLineCount();let n=a.lineNumber+1,i=1;return n>o&&(n=o,i=e.getLineMaxColumn(n)),CursorState.fromViewState(t.viewState.move(t.modelState.hasSelection(),n,i,0))}{const e=t.modelState.selectionStart.getEndPosition();return CursorState.fromModelState(t.modelState.move(t.modelState.hasSelection(),e.lineNumber,e.column,0))}}static word(e,t,o,n){const i=e.model.validatePosition(n);return CursorState.fromModelState(WordOperations.word(e.cursorConfig,e.model,t.modelState,o,i))}static cancelSelection(e,t){if(!t.modelState.hasSelection())return new CursorState(t.modelState,t.viewState);const o=t.viewState.position.lineNumber,n=t.viewState.position.column;return CursorState.fromViewState(new SingleCursorState(new Range(o,n,o,n),0,new Position(o,n),0))}static moveTo(e,t,o,n,i){const r=e.model.validatePosition(n),a=i?e.coordinatesConverter.validateViewPosition(new Position(i.lineNumber,i.column),r):e.coordinatesConverter.convertModelPositionToViewPosition(r);return CursorState.fromViewState(t.viewState.move(o,a.lineNumber,a.column,0))}static simpleMove(e,t,o,n,i,r){switch(o){case 0:return 4===r?this._moveHalfLineLeft(e,t,n):this._moveLeft(e,t,n,i);case 1:return 4===r?this._moveHalfLineRight(e,t,n):this._moveRight(e,t,n,i);case 2:return 2===r?this._moveUpByViewLines(e,t,n,i):this._moveUpByModelLines(e,t,n,i);case 3:return 2===r?this._moveDownByViewLines(e,t,n,i):this._moveDownByModelLines(e,t,n,i);case 4:return 2===r?t.map((t=>CursorState.fromViewState(MoveOperations.moveToPrevBlankLine(e.cursorConfig,e,t.viewState,n)))):t.map((t=>CursorState.fromModelState(MoveOperations.moveToPrevBlankLine(e.cursorConfig,e.model,t.modelState,n))));case 5:return 2===r?t.map((t=>CursorState.fromViewState(MoveOperations.moveToNextBlankLine(e.cursorConfig,e,t.viewState,n)))):t.map((t=>CursorState.fromModelState(MoveOperations.moveToNextBlankLine(e.cursorConfig,e.model,t.modelState,n))));case 6:return this._moveToViewMinColumn(e,t,n);case 7:return this._moveToViewFirstNonWhitespaceColumn(e,t,n);case 8:return this._moveToViewCenterColumn(e,t,n);case 9:return this._moveToViewMaxColumn(e,t,n);case 10:return this._moveToViewLastNonWhitespaceColumn(e,t,n);default:return null}}static viewportMove(e,t,o,n,i){const r=e.getCompletelyVisibleViewRange(),a=e.coordinatesConverter.convertViewRangeToModelRange(r);switch(o){case 11:{const o=this._firstLineNumberInRange(e.model,a,i),r=e.model.getLineFirstNonWhitespaceColumn(o);return[this._moveToModelPosition(e,t[0],n,o,r)]}case 13:{const o=this._lastLineNumberInRange(e.model,a,i),r=e.model.getLineFirstNonWhitespaceColumn(o);return[this._moveToModelPosition(e,t[0],n,o,r)]}case 12:{const o=Math.round((a.startLineNumber+a.endLineNumber)/2),i=e.model.getLineFirstNonWhitespaceColumn(o);return[this._moveToModelPosition(e,t[0],n,o,i)]}case 14:{const o=[];for(let i=0,a=t.length;i<a;i++){const a=t[i];o[i]=this.findPositionInViewportIfOutside(e,a,r,n)}return o}default:return null}}static findPositionInViewportIfOutside(e,t,o,n){const i=t.viewState.position.lineNumber;if(o.startLineNumber<=i&&i<=o.endLineNumber-1)return new CursorState(t.modelState,t.viewState);{let r;r=i>o.endLineNumber-1?o.endLineNumber-1:i<o.startLineNumber?o.startLineNumber:i;const a=MoveOperations.vertical(e.cursorConfig,e,i,t.viewState.position.column,t.viewState.leftoverVisibleColumns,r,!1);return CursorState.fromViewState(t.viewState.move(n,a.lineNumber,a.column,a.leftoverVisibleColumns))}}static _firstLineNumberInRange(e,t,o){let n=t.startLineNumber;return t.startColumn!==e.getLineMinColumn(n)&&n++,Math.min(t.endLineNumber,n+o-1)}static _lastLineNumberInRange(e,t,o){let n=t.startLineNumber;return t.startColumn!==e.getLineMinColumn(n)&&n++,Math.max(n,t.endLineNumber-o+1)}static _moveLeft(e,t,o,n){return t.map((t=>CursorState.fromViewState(MoveOperations.moveLeft(e.cursorConfig,e,t.viewState,o,n))))}static _moveHalfLineLeft(e,t,o){const n=[];for(let i=0,r=t.length;i<r;i++){const r=t[i],a=r.viewState.position.lineNumber,s=Math.round(e.getLineContent(a).length/2);n[i]=CursorState.fromViewState(MoveOperations.moveLeft(e.cursorConfig,e,r.viewState,o,s))}return n}static _moveRight(e,t,o,n){return t.map((t=>CursorState.fromViewState(MoveOperations.moveRight(e.cursorConfig,e,t.viewState,o,n))))}static _moveHalfLineRight(e,t,o){const n=[];for(let i=0,r=t.length;i<r;i++){const r=t[i],a=r.viewState.position.lineNumber,s=Math.round(e.getLineContent(a).length/2);n[i]=CursorState.fromViewState(MoveOperations.moveRight(e.cursorConfig,e,r.viewState,o,s))}return n}static _moveDownByViewLines(e,t,o,n){const i=[];for(let r=0,a=t.length;r<a;r++){const a=t[r];i[r]=CursorState.fromViewState(MoveOperations.moveDown(e.cursorConfig,e,a.viewState,o,n))}return i}static _moveDownByModelLines(e,t,o,n){const i=[];for(let r=0,a=t.length;r<a;r++){const a=t[r];i[r]=CursorState.fromModelState(MoveOperations.moveDown(e.cursorConfig,e.model,a.modelState,o,n))}return i}static _moveUpByViewLines(e,t,o,n){const i=[];for(let r=0,a=t.length;r<a;r++){const a=t[r];i[r]=CursorState.fromViewState(MoveOperations.moveUp(e.cursorConfig,e,a.viewState,o,n))}return i}static _moveUpByModelLines(e,t,o,n){const i=[];for(let r=0,a=t.length;r<a;r++){const a=t[r];i[r]=CursorState.fromModelState(MoveOperations.moveUp(e.cursorConfig,e.model,a.modelState,o,n))}return i}static _moveToViewPosition(e,t,o,n,i){return CursorState.fromViewState(t.viewState.move(o,n,i,0))}static _moveToModelPosition(e,t,o,n,i){return CursorState.fromModelState(t.modelState.move(o,n,i,0))}static _moveToViewMinColumn(e,t,o){const n=[];for(let i=0,r=t.length;i<r;i++){const r=t[i],a=r.viewState.position.lineNumber,s=e.getLineMinColumn(a);n[i]=this._moveToViewPosition(e,r,o,a,s)}return n}static _moveToViewFirstNonWhitespaceColumn(e,t,o){const n=[];for(let i=0,r=t.length;i<r;i++){const r=t[i],a=r.viewState.position.lineNumber,s=e.getLineFirstNonWhitespaceColumn(a);n[i]=this._moveToViewPosition(e,r,o,a,s)}return n}static _moveToViewCenterColumn(e,t,o){const n=[];for(let i=0,r=t.length;i<r;i++){const r=t[i],a=r.viewState.position.lineNumber,s=Math.round((e.getLineMaxColumn(a)+e.getLineMinColumn(a))/2);n[i]=this._moveToViewPosition(e,r,o,a,s)}return n}static _moveToViewMaxColumn(e,t,o){const n=[];for(let i=0,r=t.length;i<r;i++){const r=t[i],a=r.viewState.position.lineNumber,s=e.getLineMaxColumn(a);n[i]=this._moveToViewPosition(e,r,o,a,s)}return n}static _moveToViewLastNonWhitespaceColumn(e,t,o){const n=[];for(let i=0,r=t.length;i<r;i++){const r=t[i],a=r.viewState.position.lineNumber,s=e.getLineLastNonWhitespaceColumn(a);n[i]=this._moveToViewPosition(e,r,o,a,s)}return n}}export var CursorMove;(function(e){const t=function(e){if(!types.isObject(e))return!1;const t=e;return!!types.isString(t.to)&&(!(!types.isUndefined(t.select)&&!types.isBoolean(t.select))&&(!(!types.isUndefined(t.by)&&!types.isString(t.by))&&!(!types.isUndefined(t.value)&&!types.isNumber(t.value))))};function o(t){if(!t.to)return null;let o;switch(t.to){case e.RawDirection.Left:o=0;break;case e.RawDirection.Right:o=1;break;case e.RawDirection.Up:o=2;break;case e.RawDirection.Down:o=3;break;case e.RawDirection.PrevBlankLine:o=4;break;case e.RawDirection.NextBlankLine:o=5;break;case e.RawDirection.WrappedLineStart:o=6;break;case e.RawDirection.WrappedLineFirstNonWhitespaceCharacter:o=7;break;case e.RawDirection.WrappedLineColumnCenter:o=8;break;case e.RawDirection.WrappedLineEnd:o=9;break;case e.RawDirection.WrappedLineLastNonWhitespaceCharacter:o=10;break;case e.RawDirection.ViewPortTop:o=11;break;case e.RawDirection.ViewPortBottom:o=13;break;case e.RawDirection.ViewPortCenter:o=12;break;case e.RawDirection.ViewPortIfOutside:o=14;break;default:return null}let n=0;switch(t.by){case e.RawUnit.Line:n=1;break;case e.RawUnit.WrappedLine:n=2;break;case e.RawUnit.Character:n=3;break;case e.RawUnit.HalfLine:n=4;break}return{direction:o,unit:n,select:!!t.select,value:t.value||1}}e.description={description:"Move cursor to a logical position in the view",args:[{name:"Cursor move argument object",description:"Property-value pairs that can be passed through this argument:\n\t\t\t\t\t* 'to': A mandatory logical position value providing where to move the cursor.\n\t\t\t\t\t\t```\n\t\t\t\t\t\t'left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine',\n\t\t\t\t\t\t'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'\n\t\t\t\t\t\t'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'\n\t\t\t\t\t\t'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'\n\t\t\t\t\t\t```\n\t\t\t\t\t* 'by': Unit to move. Default is computed based on 'to' value.\n\t\t\t\t\t\t```\n\t\t\t\t\t\t'line', 'wrappedLine', 'character', 'halfLine'\n\t\t\t\t\t\t```\n\t\t\t\t\t* 'value': Number of units to move. Default is '1'.\n\t\t\t\t\t* 'select': If 'true' makes the selection. Default is 'false'.\n\t\t\t\t",constraint:t,schema:{type:"object",required:["to"],properties:{to:{type:"string",enum:["left","right","up","down","prevBlankLine","nextBlankLine","wrappedLineStart","wrappedLineEnd","wrappedLineColumnCenter","wrappedLineFirstNonWhitespaceCharacter","wrappedLineLastNonWhitespaceCharacter","viewPortTop","viewPortCenter","viewPortBottom","viewPortIfOutside"]},by:{type:"string",enum:["line","wrappedLine","character","halfLine"]},value:{type:"number",default:1},select:{type:"boolean",default:!1}}}}]},e.RawDirection={Left:"left",Right:"right",Up:"up",Down:"down",PrevBlankLine:"prevBlankLine",NextBlankLine:"nextBlankLine",WrappedLineStart:"wrappedLineStart",WrappedLineFirstNonWhitespaceCharacter:"wrappedLineFirstNonWhitespaceCharacter",WrappedLineColumnCenter:"wrappedLineColumnCenter",WrappedLineEnd:"wrappedLineEnd",WrappedLineLastNonWhitespaceCharacter:"wrappedLineLastNonWhitespaceCharacter",ViewPortTop:"viewPortTop",ViewPortCenter:"viewPortCenter",ViewPortBottom:"viewPortBottom",ViewPortIfOutside:"viewPortIfOutside"},e.RawUnit={Line:"line",WrappedLine:"wrappedLine",Character:"character",HalfLine:"halfLine"},e.parse=o})(CursorMove||(CursorMove={}));