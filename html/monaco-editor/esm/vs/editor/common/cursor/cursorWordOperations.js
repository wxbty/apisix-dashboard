import*as strings from"../../../base/common/strings.js";import{SingleCursorState}from"./cursorCommon.js";import{DeleteOperations}from"./cursorDeleteOperations.js";import{getMapForWordSeparators}from"../core/wordCharacterClassifier.js";import{Position}from"../core/position.js";import{Range}from"../core/range.js";export class WordOperations{static _createWord(e,t,n,r,o){return{start:r,end:o,wordType:t,nextCharClass:n}}static _findPreviousWordOnLine(e,t,n){const r=t.getLineContent(n.lineNumber);return this._doFindPreviousWordOnLine(r,e,n)}static _doFindPreviousWordOnLine(e,t,n){let r=0;for(let o=n.column-2;o>=0;o--){const n=e.charCodeAt(o),i=t.get(n);if(0===i){if(2===r)return this._createWord(e,r,i,o+1,this._findEndOfWord(e,t,r,o+1));r=1}else if(2===i){if(1===r)return this._createWord(e,r,i,o+1,this._findEndOfWord(e,t,r,o+1));r=2}else if(1===i&&0!==r)return this._createWord(e,r,i,o+1,this._findEndOfWord(e,t,r,o+1))}return 0!==r?this._createWord(e,r,1,0,this._findEndOfWord(e,t,r,0)):null}static _findEndOfWord(e,t,n,r){const o=e.length;for(let i=r;i<o;i++){const r=e.charCodeAt(i),o=t.get(r);if(1===o)return i;if(1===n&&2===o)return i;if(2===n&&0===o)return i}return o}static _findNextWordOnLine(e,t,n){const r=t.getLineContent(n.lineNumber);return this._doFindNextWordOnLine(r,e,n)}static _doFindNextWordOnLine(e,t,n){let r=0;const o=e.length;for(let i=n.column-1;i<o;i++){const n=e.charCodeAt(i),o=t.get(n);if(0===o){if(2===r)return this._createWord(e,r,o,this._findStartOfWord(e,t,r,i-1),i);r=1}else if(2===o){if(1===r)return this._createWord(e,r,o,this._findStartOfWord(e,t,r,i-1),i);r=2}else if(1===o&&0!==r)return this._createWord(e,r,o,this._findStartOfWord(e,t,r,i-1),i)}return 0!==r?this._createWord(e,r,1,this._findStartOfWord(e,t,r,o-1),o):null}static _findStartOfWord(e,t,n,r){for(let o=r;o>=0;o--){const r=e.charCodeAt(o),i=t.get(r);if(1===i)return o+1;if(1===n&&2===i)return o+1;if(2===n&&0===i)return o+1}return 0}static moveWordLeft(e,t,n,r){let o=n.lineNumber,i=n.column;1===i&&o>1&&(o-=1,i=t.getLineMaxColumn(o));let s=WordOperations._findPreviousWordOnLine(e,t,new Position(o,i));if(0===r)return new Position(o,s?s.start+1:1);if(1===r)return s&&2===s.wordType&&s.end-s.start===1&&0===s.nextCharClass&&(s=WordOperations._findPreviousWordOnLine(e,t,new Position(o,s.start+1))),new Position(o,s?s.start+1:1);if(3===r){while(s&&2===s.wordType)s=WordOperations._findPreviousWordOnLine(e,t,new Position(o,s.start+1));return new Position(o,s?s.start+1:1)}return s&&i<=s.end+1&&(s=WordOperations._findPreviousWordOnLine(e,t,new Position(o,s.start+1))),new Position(o,s?s.end+1:1)}static _moveWordPartLeft(e,t){const n=t.lineNumber,r=e.getLineMaxColumn(n);if(1===t.column)return n>1?new Position(n-1,e.getLineMaxColumn(n-1)):t;const o=e.getLineContent(n);for(let i=t.column-1;i>1;i--){const e=o.charCodeAt(i-2),t=o.charCodeAt(i-1);if(95===e&&95!==t)return new Position(n,i);if(strings.isLowerAsciiLetter(e)&&strings.isUpperAsciiLetter(t))return new Position(n,i);if(strings.isUpperAsciiLetter(e)&&strings.isUpperAsciiLetter(t)&&i+1<r){const e=o.charCodeAt(i);if(strings.isLowerAsciiLetter(e))return new Position(n,i)}}return new Position(n,1)}static moveWordRight(e,t,n,r){let o=n.lineNumber,i=n.column,s=!1;i===t.getLineMaxColumn(o)&&o<t.getLineCount()&&(s=!0,o+=1,i=1);let a=WordOperations._findNextWordOnLine(e,t,new Position(o,i));if(2===r)a&&2===a.wordType&&a.end-a.start===1&&0===a.nextCharClass&&(a=WordOperations._findNextWordOnLine(e,t,new Position(o,a.end+1))),i=a?a.end+1:t.getLineMaxColumn(o);else if(3===r){s&&(i=0);while(a&&(2===a.wordType||a.start+1<=i))a=WordOperations._findNextWordOnLine(e,t,new Position(o,a.end+1));i=a?a.start+1:t.getLineMaxColumn(o)}else a&&!s&&i>=a.start+1&&(a=WordOperations._findNextWordOnLine(e,t,new Position(o,a.end+1))),i=a?a.start+1:t.getLineMaxColumn(o);return new Position(o,i)}static _moveWordPartRight(e,t){const n=t.lineNumber,r=e.getLineMaxColumn(n);if(t.column===r)return n<e.getLineCount()?new Position(n+1,1):t;const o=e.getLineContent(n);for(let i=t.column+1;i<r;i++){const e=o.charCodeAt(i-2),t=o.charCodeAt(i-1);if(95!==e&&95===t)return new Position(n,i);if(strings.isLowerAsciiLetter(e)&&strings.isUpperAsciiLetter(t))return new Position(n,i);if(strings.isUpperAsciiLetter(e)&&strings.isUpperAsciiLetter(t)&&i+1<r){const e=o.charCodeAt(i);if(strings.isLowerAsciiLetter(e))return new Position(n,i)}}return new Position(n,r)}static _deleteWordLeftWhitespace(e,t){const n=e.getLineContent(t.lineNumber),r=t.column-2,o=strings.lastNonWhitespaceIndex(n,r);return o+1<r?new Range(t.lineNumber,o+2,t.lineNumber,t.column):null}static deleteWordLeft(e,t){const n=e.wordSeparators,r=e.model,o=e.selection,i=e.whitespaceHeuristics;if(!o.isEmpty())return o;if(DeleteOperations.isAutoClosingPairDelete(e.autoClosingDelete,e.autoClosingBrackets,e.autoClosingQuotes,e.autoClosingPairs.autoClosingPairsOpenByEnd,e.model,[e.selection],e.autoClosedCharacters)){const t=e.selection.getPosition();return new Range(t.lineNumber,t.column-1,t.lineNumber,t.column+1)}const s=new Position(o.positionLineNumber,o.positionColumn);let a=s.lineNumber,d=s.column;if(1===a&&1===d)return null;if(i){const e=this._deleteWordLeftWhitespace(r,s);if(e)return e}let l=WordOperations._findPreviousWordOnLine(n,r,s);return 0===t?l?d=l.start+1:d>1?d=1:(a--,d=r.getLineMaxColumn(a)):(l&&d<=l.end+1&&(l=WordOperations._findPreviousWordOnLine(n,r,new Position(a,l.start+1))),l?d=l.end+1:d>1?d=1:(a--,d=r.getLineMaxColumn(a))),new Range(a,d,s.lineNumber,s.column)}static deleteInsideWord(e,t,n){if(!n.isEmpty())return n;const r=new Position(n.positionLineNumber,n.positionColumn),o=this._deleteInsideWordWhitespace(t,r);return o||this._deleteInsideWordDetermineDeleteRange(e,t,r)}static _charAtIsWhitespace(e,t){const n=e.charCodeAt(t);return 32===n||9===n}static _deleteInsideWordWhitespace(e,t){const n=e.getLineContent(t.lineNumber),r=n.length;if(0===r)return null;let o=Math.max(t.column-2,0);if(!this._charAtIsWhitespace(n,o))return null;let i=Math.min(t.column-1,r-1);if(!this._charAtIsWhitespace(n,i))return null;while(o>0&&this._charAtIsWhitespace(n,o-1))o--;while(i+1<r&&this._charAtIsWhitespace(n,i+1))i++;return new Range(t.lineNumber,o+1,t.lineNumber,i+2)}static _deleteInsideWordDetermineDeleteRange(e,t,n){const r=t.getLineContent(n.lineNumber),o=r.length;if(0===o)return n.lineNumber>1?new Range(n.lineNumber-1,t.getLineMaxColumn(n.lineNumber-1),n.lineNumber,1):n.lineNumber<t.getLineCount()?new Range(n.lineNumber,1,n.lineNumber+1,1):new Range(n.lineNumber,1,n.lineNumber,1);const i=e=>e.start+1<=n.column&&n.column<=e.end+1,s=(e,t)=>(e=Math.min(e,n.column),t=Math.max(t,n.column),new Range(n.lineNumber,e,n.lineNumber,t)),a=e=>{let t=e.start+1,n=e.end+1,i=!1;while(n-1<o&&this._charAtIsWhitespace(r,n-1))i=!0,n++;if(!i)while(t>1&&this._charAtIsWhitespace(r,t-2))t--;return s(t,n)},d=WordOperations._findPreviousWordOnLine(e,t,n);if(d&&i(d))return a(d);const l=WordOperations._findNextWordOnLine(e,t,n);return l&&i(l)?a(l):d&&l?s(d.end+1,l.start+1):d?s(d.start+1,d.end+1):l?s(l.start+1,l.end+1):s(1,o+1)}static _deleteWordPartLeft(e,t){if(!t.isEmpty())return t;const n=t.getPosition(),r=WordOperations._moveWordPartLeft(e,n);return new Range(n.lineNumber,n.column,r.lineNumber,r.column)}static _findFirstNonWhitespaceChar(e,t){const n=e.length;for(let r=t;r<n;r++){const t=e.charAt(r);if(" "!==t&&"\t"!==t)return r}return n}static _deleteWordRightWhitespace(e,t){const n=e.getLineContent(t.lineNumber),r=t.column-1,o=this._findFirstNonWhitespaceChar(n,r);return r+1<o?new Range(t.lineNumber,t.column,t.lineNumber,o+1):null}static deleteWordRight(e,t){const n=e.wordSeparators,r=e.model,o=e.selection,i=e.whitespaceHeuristics;if(!o.isEmpty())return o;const s=new Position(o.positionLineNumber,o.positionColumn);let a=s.lineNumber,d=s.column;const l=r.getLineCount(),u=r.getLineMaxColumn(a);if(a===l&&d===u)return null;if(i){const e=this._deleteWordRightWhitespace(r,s);if(e)return e}let c=WordOperations._findNextWordOnLine(n,r,s);return 2===t?c?d=c.end+1:d<u||a===l?d=u:(a++,c=WordOperations._findNextWordOnLine(n,r,new Position(a,1)),d=c?c.start+1:r.getLineMaxColumn(a)):(c&&d>=c.start+1&&(c=WordOperations._findNextWordOnLine(n,r,new Position(a,c.end+1))),c?d=c.start+1:d<u||a===l?d=u:(a++,c=WordOperations._findNextWordOnLine(n,r,new Position(a,1)),d=c?c.start+1:r.getLineMaxColumn(a))),new Range(a,d,s.lineNumber,s.column)}static _deleteWordPartRight(e,t){if(!t.isEmpty())return t;const n=t.getPosition(),r=WordOperations._moveWordPartRight(e,n);return new Range(n.lineNumber,n.column,r.lineNumber,r.column)}static _createWordAtPosition(e,t,n){const r=new Range(t,n.start+1,t,n.end+1);return{word:e.getValueInRange(r),startColumn:r.startColumn,endColumn:r.endColumn}}static getWordAtPosition(e,t,n){const r=getMapForWordSeparators(t),o=WordOperations._findPreviousWordOnLine(r,e,n);if(o&&1===o.wordType&&o.start<=n.column-1&&n.column-1<=o.end)return WordOperations._createWordAtPosition(e,n.lineNumber,o);const i=WordOperations._findNextWordOnLine(r,e,n);return i&&1===i.wordType&&i.start<=n.column-1&&n.column-1<=i.end?WordOperations._createWordAtPosition(e,n.lineNumber,i):null}static word(e,t,n,r,o){const i=getMapForWordSeparators(e.wordSeparators),s=WordOperations._findPreviousWordOnLine(i,t,o),a=WordOperations._findNextWordOnLine(i,t,o);if(!r){let e,n;return s&&1===s.wordType&&s.start<=o.column-1&&o.column-1<=s.end?(e=s.start+1,n=s.end+1):a&&1===a.wordType&&a.start<=o.column-1&&o.column-1<=a.end?(e=a.start+1,n=a.end+1):(e=s?s.end+1:1,n=a?a.start+1:t.getLineMaxColumn(o.lineNumber)),new SingleCursorState(new Range(o.lineNumber,e,o.lineNumber,n),0,new Position(o.lineNumber,n),0)}let d,l;s&&1===s.wordType&&s.start<o.column-1&&o.column-1<s.end?(d=s.start+1,l=s.end+1):a&&1===a.wordType&&a.start<o.column-1&&o.column-1<a.end?(d=a.start+1,l=a.end+1):(d=o.column,l=o.column);const u=o.lineNumber;let c;if(n.selectionStart.containsPosition(o))c=n.selectionStart.endColumn;else if(o.isBeforeOrEqual(n.selectionStart.getStartPosition())){c=d;const e=new Position(u,c);n.selectionStart.containsPosition(e)&&(c=n.selectionStart.endColumn)}else{c=l;const e=new Position(u,c);n.selectionStart.containsPosition(e)&&(c=n.selectionStart.startColumn)}return n.move(!0,u,c,0)}}export class WordPartOperations extends WordOperations{static deleteWordPartLeft(e){const t=enforceDefined([WordOperations.deleteWordLeft(e,0),WordOperations.deleteWordLeft(e,2),WordOperations._deleteWordPartLeft(e.model,e.selection)]);return t.sort(Range.compareRangesUsingEnds),t[2]}static deleteWordPartRight(e){const t=enforceDefined([WordOperations.deleteWordRight(e,0),WordOperations.deleteWordRight(e,2),WordOperations._deleteWordPartRight(e.model,e.selection)]);return t.sort(Range.compareRangesUsingStarts),t[0]}static moveWordPartLeft(e,t,n){const r=enforceDefined([WordOperations.moveWordLeft(e,t,n,0),WordOperations.moveWordLeft(e,t,n,2),WordOperations._moveWordPartLeft(t,n)]);return r.sort(Position.compare),r[2]}static moveWordPartRight(e,t,n){const r=enforceDefined([WordOperations.moveWordRight(e,t,n,0),WordOperations.moveWordRight(e,t,n,2),WordOperations._moveWordPartRight(t,n)]);return r.sort(Position.compare),r[0]}}function enforceDefined(e){return e.filter((e=>Boolean(e)))}