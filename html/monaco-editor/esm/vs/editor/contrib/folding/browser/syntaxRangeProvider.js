import{onUnexpectedExternalError}from"../../../../base/common/errors.js";import{DisposableStore}from"../../../../base/common/lifecycle.js";import{FoldingRegions,MAX_LINE_NUMBER}from"./foldingRanges.js";const foldingContext={};export const ID_SYNTAX_PROVIDER="syntax";export class SyntaxRangeProvider{constructor(t,e,n,s){this.editorModel=t,this.providers=e,this.limit=s,this.id=ID_SYNTAX_PROVIDER;for(const i of e)"function"===typeof i.onDidChange&&(this.disposables||(this.disposables=new DisposableStore),this.disposables.add(i.onDidChange(n)))}compute(t,e){return collectSyntaxRanges(this.providers,this.editorModel,t).then((t=>{if(t){let n=sanitizeRanges(t,this.limit,e);return n}return null}))}dispose(){var t;null===(t=this.disposables)||void 0===t||t.dispose()}}function collectSyntaxRanges(t,e,n){let s=null,i=t.map(((t,i)=>Promise.resolve(t.provideFoldingRanges(e,foldingContext,n)).then((t=>{if(!n.isCancellationRequested&&Array.isArray(t)){Array.isArray(s)||(s=[]);let n=e.getLineCount();for(let e of t)e.start>0&&e.end>e.start&&e.end<=n&&s.push({start:e.start,end:e.end,rank:i,kind:e.kind})}}),onUnexpectedExternalError)));return Promise.all(i).then((t=>s))}export class RangesCollector{constructor(t,e){this._notifyTooManyRegions=e,this._startIndexes=[],this._endIndexes=[],this._nestingLevels=[],this._nestingLevelCounts=[],this._types=[],this._length=0,this._foldingRangesLimit=t}add(t,e,n,s){if(t>MAX_LINE_NUMBER||e>MAX_LINE_NUMBER)return;let i=this._length;this._startIndexes[i]=t,this._endIndexes[i]=e,this._nestingLevels[i]=s,this._types[i]=n,this._length++,s<30&&(this._nestingLevelCounts[s]=(this._nestingLevelCounts[s]||0)+1)}toIndentRanges(){if(this._length<=this._foldingRangesLimit){let t=new Uint32Array(this._length),e=new Uint32Array(this._length);for(let n=0;n<this._length;n++)t[n]=this._startIndexes[n],e[n]=this._endIndexes[n];return new FoldingRegions(t,e,this._types)}{this._notifyTooManyRegions&&this._notifyTooManyRegions(this._foldingRangesLimit);let t=0,e=this._nestingLevelCounts.length;for(let o=0;o<this._nestingLevelCounts.length;o++){let n=this._nestingLevelCounts[o];if(n){if(n+t>this._foldingRangesLimit){e=o;break}t+=n}}let n=new Uint32Array(this._foldingRangesLimit),s=new Uint32Array(this._foldingRangesLimit),i=[];for(let o=0,r=0;o<this._length;o++){let l=this._nestingLevels[o];(l<e||l===e&&t++<this._foldingRangesLimit)&&(n[r]=this._startIndexes[o],s[r]=this._endIndexes[o],i[r]=this._types[o],r++)}return new FoldingRegions(n,s,i)}}}export function sanitizeRanges(t,e,n){let s,i=t.sort(((t,e)=>{let n=t.start-e.start;return 0===n&&(n=t.rank-e.rank),n})),o=new RangesCollector(e,n),r=[];for(let l of i)if(s){if(l.start>s.start)if(l.end<=s.end)r.push(s),s=l,o.add(l.start,l.end,l.kind&&l.kind.value,r.length);else{if(l.start>s.end){do{s=r.pop()}while(s&&l.start>s.end);s&&r.push(s),s=l}o.add(l.start,l.end,l.kind&&l.kind.value,r.length)}}else s=l,o.add(l.start,l.end,l.kind&&l.kind.value,r.length);return o.toIndentRanges()}