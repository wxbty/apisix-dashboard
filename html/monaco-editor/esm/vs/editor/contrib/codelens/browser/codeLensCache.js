var __decorate=this&&this.__decorate||function(e,t,o,n){var r,s=arguments.length,a=s<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,o):n;if("object"===typeof Reflect&&"function"===typeof Reflect.decorate)a=Reflect.decorate(e,t,o,n);else for(var c=e.length-1;c>=0;c--)(r=e[c])&&(a=(s<3?r(a):s>3?r(t,o,a):r(t,o))||a);return s>3&&a&&Object.defineProperty(t,o,a),a},__param=this&&this.__param||function(e,t){return function(o,n){t(o,n,e)}};import{runWhenIdle}from"../../../../base/common/async.js";import{once}from"../../../../base/common/functional.js";import{LRUCache}from"../../../../base/common/map.js";import{Range}from"../../../common/core/range.js";import{CodeLensModel}from"./codelens.js";import{registerSingleton}from"../../../../platform/instantiation/common/extensions.js";import{createDecorator}from"../../../../platform/instantiation/common/instantiation.js";import{IStorageService,WillSaveStateReason}from"../../../../platform/storage/common/storage.js";export const ICodeLensCache=createDecorator("ICodeLensCache");class CacheItem{constructor(e,t){this.lineCount=e,this.data=t}}let CodeLensCache=class{constructor(e){this._fakeProvider=new class{provideCodeLenses(){throw new Error("not supported")}},this._cache=new LRUCache(20,.75);const t="codelens/cache";runWhenIdle((()=>e.remove(t,1)));const o="codelens/cache2",n=e.get(o,1,"{}");this._deserialize(n),once(e.onWillSaveState)((t=>{t.reason===WillSaveStateReason.SHUTDOWN&&e.store(o,this._serialize(),1,1)}))}put(e,t){const o=t.lenses.map((e=>{var t;return{range:e.symbol.range,command:e.symbol.command&&{id:"",title:null===(t=e.symbol.command)||void 0===t?void 0:t.title}}})),n=new CodeLensModel;n.add({lenses:o,dispose:()=>{}},this._fakeProvider);const r=new CacheItem(e.getLineCount(),n);this._cache.set(e.uri.toString(),r)}get(e){const t=this._cache.get(e.uri.toString());return t&&t.lineCount===e.getLineCount()?t.data:void 0}delete(e){this._cache.delete(e.uri.toString())}_serialize(){const e=Object.create(null);for(const[t,o]of this._cache){const n=new Set;for(const e of o.data.lenses)n.add(e.symbol.range.startLineNumber);e[t]={lineCount:o.lineCount,lines:[...n.values()]}}return JSON.stringify(e)}_deserialize(e){try{const t=JSON.parse(e);for(const e in t){const o=t[e],n=[];for(const e of o.lines)n.push({range:new Range(e,1,e,11)});const r=new CodeLensModel;r.add({lenses:n,dispose(){}},this._fakeProvider),this._cache.set(e,new CacheItem(o.lineCount,r))}}catch(t){}}};CodeLensCache=__decorate([__param(0,IStorageService)],CodeLensCache);export{CodeLensCache};registerSingleton(ICodeLensCache,CodeLensCache);