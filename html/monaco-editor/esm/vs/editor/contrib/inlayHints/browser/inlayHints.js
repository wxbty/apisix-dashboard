var __awaiter=this&&this.__awaiter||function(t,e,i,o){function n(t){return t instanceof i?t:new i((function(e){e(t)}))}return new(i||(i=Promise))((function(i,s){function r(t){try{l(o.next(t))}catch(e){s(e)}}function a(t){try{l(o["throw"](t))}catch(e){s(e)}}function l(t){t.done?i(t.value):n(t.value).then(r,a)}l((o=o.apply(t,e||[])).next())}))};import{CancellationError,onUnexpectedExternalError}from"../../../../base/common/errors.js";import{DisposableStore}from"../../../../base/common/lifecycle.js";import{Position}from"../../../common/core/position.js";import{Range}from"../../../common/core/range.js";import{InlayHintsProviderRegistry}from"../../../common/languages.js";export class InlayHintAnchor{constructor(t,e){this.range=t,this.direction=e}}export class InlayHintItem{constructor(t,e,i){this.hint=t,this.anchor=e,this.provider=i,this._isResolved=!1}with(t){const e=new InlayHintItem(this.hint,t.anchor,this.provider);return e._isResolved=this._isResolved,e._currentResolve=this._currentResolve,e}resolve(t){return __awaiter(this,void 0,void 0,(function*(){if("function"===typeof this.provider.resolveInlayHint){if(this._currentResolve){if(yield this._currentResolve,t.isCancellationRequested)return;return this.resolve(t)}this._isResolved||(this._currentResolve=this._doResolve(t).finally((()=>this._currentResolve=void 0))),yield this._currentResolve}}))}_doResolve(t){var e,i;return __awaiter(this,void 0,void 0,(function*(){try{const o=yield Promise.resolve(this.provider.resolveInlayHint(this.hint,t));this.hint.tooltip=null!==(e=null===o||void 0===o?void 0:o.tooltip)&&void 0!==e?e:this.hint.tooltip,this.hint.label=null!==(i=null===o||void 0===o?void 0:o.label)&&void 0!==i?i:this.hint.label,this._isResolved=!0}catch(o){onUnexpectedExternalError(o),this._isResolved=!1}}))}}export class InlayHintsFragments{constructor(t,e,i){this._disposables=new DisposableStore,this.ranges=t,this.provider=new Set;const o=[];for(const[n,s]of e){this._disposables.add(n),this.provider.add(s);for(const t of n.hints){let e=i.validatePosition(t.position),n="before";const r=InlayHintsFragments._getRangeAtPosition(i,e);let a;r.getStartPosition().isBefore(e)?(a=Range.fromPositions(r.getStartPosition(),e),n="after"):(a=Range.fromPositions(e,r.getEndPosition()),n="before"),o.push(new InlayHintItem(t,new InlayHintAnchor(a,n),s))}}this.items=o.sort(((t,e)=>Position.compare(t.hint.position,e.hint.position)))}static create(t,e,i){return __awaiter(this,void 0,void 0,(function*(){const o=[],n=InlayHintsProviderRegistry.ordered(t).reverse().map((n=>e.map((e=>__awaiter(this,void 0,void 0,(function*(){try{const s=yield n.provideInlayHints(t,e,i);(null===s||void 0===s?void 0:s.hints.length)&&o.push([s,n])}catch(s){onUnexpectedExternalError(s)}}))))));if(yield Promise.all(n.flat()),i.isCancellationRequested||t.isDisposed())throw new CancellationError;return new InlayHintsFragments(e,o,t)}))}dispose(){this._disposables.dispose()}static _getRangeAtPosition(t,e){const i=e.lineNumber,o=t.getWordAtPosition(e);if(o)return new Range(i,o.startColumn,i,o.endColumn);t.tokenizeIfCheap(i);const n=t.getLineTokens(i),s=e.column-1,r=n.findTokenIndexAtOffset(s);let a=n.getStartOffset(r),l=n.getEndOffset(r);return l-a===1&&(a===s&&r>1?(a=n.getStartOffset(r-1),l=n.getEndOffset(r-1)):l===s&&r<n.getCount()-1&&(a=n.getStartOffset(r+1),l=n.getEndOffset(r+1))),new Range(i,a+1,i,l+1)}}