export function tail(t,e=0){return t[t.length-(1+e)]}export function tail2(t){if(0===t.length)throw new Error("Invalid tail call");return[t.slice(0,t.length-1),t[t.length-1]]}export function equals(t,e,n=((t,e)=>t===e)){if(t===e)return!0;if(!t||!e)return!1;if(t.length!==e.length)return!1;for(let r=0,i=t.length;r<i;r++)if(!n(t[r],e[r]))return!1;return!0}export function binarySearch(t,e,n){let r=0,i=t.length-1;while(r<=i){const s=(r+i)/2|0,o=n(t[s],e);if(o<0)r=s+1;else{if(!(o>0))return s;i=s-1}}return-(r+1)}export function findFirstInSorted(t,e){let n=0,r=t.length;if(0===r)return 0;while(n<r){const i=Math.floor((n+r)/2);e(t[i])?r=i:n=i+1}return n}export function quickSelect(t,e,n){if(t|=0,t>=e.length)throw new TypeError("invalid index");let r=e[Math.floor(e.length*Math.random())],i=[],s=[],o=[];for(let l of e){const t=n(l,r);t<0?i.push(l):t>0?s.push(l):o.push(l)}return t<i.length?quickSelect(t,i,n):t<i.length+o.length?o[0]:quickSelect(t-(i.length+o.length),s,n)}export function groupBy(t,e){const n=[];let r;for(const i of t.slice(0).sort(e))r&&0===e(r[0],i)?r.push(i):(r=[i],n.push(r));return n}export function coalesce(t){return t.filter((t=>!!t))}export function isFalsyOrEmpty(t){return!Array.isArray(t)||0===t.length}export function isNonEmptyArray(t){return Array.isArray(t)&&t.length>0}export function distinct(t,e=(t=>t)){const n=new Set;return t.filter((t=>{const r=e(t);return!n.has(r)&&(n.add(r),!0)}))}export function findLast(t,e){const n=lastIndex(t,e);if(-1!==n)return t[n]}export function lastIndex(t,e){for(let n=t.length-1;n>=0;n--){const r=t[n];if(e(r))return n}return-1}export function firstOrDefault(t,e){return t.length>0?t[0]:e}export function flatten(t){return[].concat(...t)}export function range(t,e){let n="number"===typeof e?t:0;"number"===typeof e?n=t:(n=0,e=t);const r=[];if(n<=e)for(let i=n;i<e;i++)r.push(i);else for(let i=n;i>e;i--)r.push(i);return r}export function arrayInsert(t,e,n){const r=t.slice(0,e),i=t.slice(e);return r.concat(n,i)}export function pushToStart(t,e){const n=t.indexOf(e);n>-1&&(t.splice(n,1),t.unshift(e))}export function pushToEnd(t,e){const n=t.indexOf(e);n>-1&&(t.splice(n,1),t.push(e))}export function asArray(t){return Array.isArray(t)?t:[t]}export function insertInto(t,e,n){const r=getActualStartIndex(t,e),i=t.length,s=n.length;t.length=i+s;for(let o=i-1;o>=r;o--)t[o+s]=t[o];for(let o=0;o<s;o++)t[o+r]=n[o]}export function splice(t,e,n,r){const i=getActualStartIndex(t,e),s=t.splice(i,n);return insertInto(t,i,r),s}function getActualStartIndex(t,e){return e<0?Math.max(e+t.length,0):Math.min(e,t.length)}export function compareBy(t,e){return(n,r)=>e(t(n),t(r))}export const numberComparator=(t,e)=>t-e;export function findMaxBy(t,e){if(0===t.length)return;let n=t[0];for(let r=1;r<t.length;r++){const i=t[r];e(i,n)>0&&(n=i)}return n}export function findLastMaxBy(t,e){if(0===t.length)return;let n=t[0];for(let r=1;r<t.length;r++){const i=t[r];e(i,n)>=0&&(n=i)}return n}export function findMinBy(t,e){return findMaxBy(t,((t,n)=>-e(t,n)))}export class ArrayQueue{constructor(t){this.items=t,this.firstIdx=0,this.lastIdx=this.items.length-1}takeWhile(t){let e=this.firstIdx;while(e<this.items.length&&t(this.items[e]))e++;const n=e===this.firstIdx?null:this.items.slice(this.firstIdx,e);return this.firstIdx=e,n}takeFromEndWhile(t){let e=this.lastIdx;while(e>=0&&t(this.items[e]))e--;const n=e===this.lastIdx?null:this.items.slice(e+1,this.lastIdx+1);return this.lastIdx=e,n}peek(){return this.items[this.firstIdx]}dequeue(){const t=this.items[this.firstIdx];return this.firstIdx++,t}takeCount(t){const e=this.items.slice(this.firstIdx,this.firstIdx+t);return this.firstIdx+=t,e}}