import{once}from"./functional.js";import{Iterable}from"./iterator.js";const TRACK_DISPOSABLES=!1;let disposableTracker=null;export function setDisposableTracker(s){disposableTracker=s}if(TRACK_DISPOSABLES){const s="__is_disposable_tracked__";setDisposableTracker(new class{trackDisposable(e){const o=new Error("Potentially leaked disposable").stack;setTimeout((()=>{e[s]||console.log(o)}),3e3)}setParent(e,o){if(e&&e!==Disposable.None)try{e[s]=!0}catch(i){}}markAsDisposed(e){if(e&&e!==Disposable.None)try{e[s]=!0}catch(o){}}markAsSingleton(s){}})}function trackDisposable(s){return null===disposableTracker||void 0===disposableTracker||disposableTracker.trackDisposable(s),s}function markAsDisposed(s){null===disposableTracker||void 0===disposableTracker||disposableTracker.markAsDisposed(s)}function setParentOfDisposable(s,e){null===disposableTracker||void 0===disposableTracker||disposableTracker.setParent(s,e)}function setParentOfDisposables(s,e){if(disposableTracker)for(const o of s)disposableTracker.setParent(o,e)}export function markAsSingleton(s){return null===disposableTracker||void 0===disposableTracker||disposableTracker.markAsSingleton(s),s}export class MultiDisposeError extends Error{constructor(s){super(`Encountered errors while disposing of store. Errors: [${s.join(", ")}]`),this.errors=s}}export function isDisposable(s){return"function"===typeof s.dispose&&0===s.dispose.length}export function dispose(s){if(Iterable.is(s)){let o=[];for(const i of s)if(i)try{i.dispose()}catch(e){o.push(e)}if(1===o.length)throw o[0];if(o.length>1)throw new MultiDisposeError(o);return Array.isArray(s)?[]:s}if(s)return s.dispose(),s}export function combinedDisposable(...s){const e=toDisposable((()=>dispose(s)));return setParentOfDisposables(s,e),e}export function toDisposable(s){const e=trackDisposable({dispose:once((()=>{markAsDisposed(e),s()}))});return e}export class DisposableStore{constructor(){this._toDispose=new Set,this._isDisposed=!1,trackDisposable(this)}dispose(){this._isDisposed||(markAsDisposed(this),this._isDisposed=!0,this.clear())}get isDisposed(){return this._isDisposed}clear(){try{dispose(this._toDispose.values())}finally{this._toDispose.clear()}}add(s){if(!s)return s;if(s===this)throw new Error("Cannot register a disposable on itself!");return setParentOfDisposable(s,this),this._isDisposed?DisposableStore.DISABLE_DISPOSED_WARNING||console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack):this._toDispose.add(s),s}}DisposableStore.DISABLE_DISPOSED_WARNING=!1;export class Disposable{constructor(){this._store=new DisposableStore,trackDisposable(this),setParentOfDisposable(this._store,this)}dispose(){markAsDisposed(this),this._store.dispose()}_register(s){if(s===this)throw new Error("Cannot register a disposable on itself!");return this._store.add(s)}}Disposable.None=Object.freeze({dispose(){}});export class MutableDisposable{constructor(){this._isDisposed=!1,trackDisposable(this)}get value(){return this._isDisposed?void 0:this._value}set value(s){var e;this._isDisposed||s===this._value||(null===(e=this._value)||void 0===e||e.dispose(),s&&setParentOfDisposable(s,this),this._value=s)}clear(){this.value=void 0}dispose(){var s;this._isDisposed=!0,markAsDisposed(this),null===(s=this._value)||void 0===s||s.dispose(),this._value=void 0}clearAndLeak(){const s=this._value;return this._value=void 0,s&&setParentOfDisposable(s,null),s}}export class ImmortalReference{constructor(s){this.object=s}dispose(){}}