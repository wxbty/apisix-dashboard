import{DiffChange}from"./diffChange.js";import{stringHash}from"../hash.js";export class StringDiffSequence{constructor(t){this.source=t}getElements(){const t=this.source,i=new Int32Array(t.length);for(let e=0,n=t.length;e<n;e++)i[e]=t.charCodeAt(e);return i}}export function stringDiff(t,i,e){return new LcsDiff(new StringDiffSequence(t),new StringDiffSequence(i)).ComputeDiff(e).changes}export class Debug{static Assert(t,i){if(!t)throw new Error(i)}}export class MyArray{static Copy(t,i,e,n,r){for(let s=0;s<r;s++)e[n+s]=t[i+s]}static Copy2(t,i,e,n,r){for(let s=0;s<r;s++)e[n+s]=t[i+s]}}class DiffChangeHelper{constructor(){this.m_changes=[],this.m_originalStart=1073741824,this.m_modifiedStart=1073741824,this.m_originalCount=0,this.m_modifiedCount=0}MarkNextChange(){(this.m_originalCount>0||this.m_modifiedCount>0)&&this.m_changes.push(new DiffChange(this.m_originalStart,this.m_originalCount,this.m_modifiedStart,this.m_modifiedCount)),this.m_originalCount=0,this.m_modifiedCount=0,this.m_originalStart=1073741824,this.m_modifiedStart=1073741824}AddOriginalElement(t,i){this.m_originalStart=Math.min(this.m_originalStart,t),this.m_modifiedStart=Math.min(this.m_modifiedStart,i),this.m_originalCount++}AddModifiedElement(t,i){this.m_originalStart=Math.min(this.m_originalStart,t),this.m_modifiedStart=Math.min(this.m_modifiedStart,i),this.m_modifiedCount++}getChanges(){return(this.m_originalCount>0||this.m_modifiedCount>0)&&this.MarkNextChange(),this.m_changes}getReverseChanges(){return(this.m_originalCount>0||this.m_modifiedCount>0)&&this.MarkNextChange(),this.m_changes.reverse(),this.m_changes}}export class LcsDiff{constructor(t,i,e=null){this.ContinueProcessingPredicate=e,this._originalSequence=t,this._modifiedSequence=i;const[n,r,s]=LcsDiff._getElements(t),[o,a,l]=LcsDiff._getElements(i);this._hasStrings=s&&l,this._originalStringElements=n,this._originalElementsOrHash=r,this._modifiedStringElements=o,this._modifiedElementsOrHash=a,this.m_forwardHistory=[],this.m_reverseHistory=[]}static _isStringArray(t){return t.length>0&&"string"===typeof t[0]}static _getElements(t){const i=t.getElements();if(LcsDiff._isStringArray(i)){const t=new Int32Array(i.length);for(let e=0,n=i.length;e<n;e++)t[e]=stringHash(i[e],0);return[i,t,!0]}return i instanceof Int32Array?[[],i,!1]:[[],new Int32Array(i),!1]}ElementsAreEqual(t,i){return this._originalElementsOrHash[t]===this._modifiedElementsOrHash[i]&&(!this._hasStrings||this._originalStringElements[t]===this._modifiedStringElements[i])}ElementsAreStrictEqual(t,i){if(!this.ElementsAreEqual(t,i))return!1;const e=LcsDiff._getStrictElement(this._originalSequence,t),n=LcsDiff._getStrictElement(this._modifiedSequence,i);return e===n}static _getStrictElement(t,i){return"function"===typeof t.getStrictElement?t.getStrictElement(i):null}OriginalElementsAreEqual(t,i){return this._originalElementsOrHash[t]===this._originalElementsOrHash[i]&&(!this._hasStrings||this._originalStringElements[t]===this._originalStringElements[i])}ModifiedElementsAreEqual(t,i){return this._modifiedElementsOrHash[t]===this._modifiedElementsOrHash[i]&&(!this._hasStrings||this._modifiedStringElements[t]===this._modifiedStringElements[i])}ComputeDiff(t){return this._ComputeDiff(0,this._originalElementsOrHash.length-1,0,this._modifiedElementsOrHash.length-1,t)}_ComputeDiff(t,i,e,n,r){const s=[!1];let o=this.ComputeDiffRecursive(t,i,e,n,s);return r&&(o=this.PrettifyChanges(o)),{quitEarly:s[0],changes:o}}ComputeDiffRecursive(t,i,e,n,r){r[0]=!1;while(t<=i&&e<=n&&this.ElementsAreEqual(t,e))t++,e++;while(i>=t&&n>=e&&this.ElementsAreEqual(i,n))i--,n--;if(t>i||e>n){let r;return e<=n?(Debug.Assert(t===i+1,"originalStart should only be one more than originalEnd"),r=[new DiffChange(t,0,e,n-e+1)]):t<=i?(Debug.Assert(e===n+1,"modifiedStart should only be one more than modifiedEnd"),r=[new DiffChange(t,i-t+1,e,0)]):(Debug.Assert(t===i+1,"originalStart should only be one more than originalEnd"),Debug.Assert(e===n+1,"modifiedStart should only be one more than modifiedEnd"),r=[]),r}const s=[0],o=[0],a=this.ComputeRecursionPoint(t,i,e,n,s,o,r),l=s[0],h=o[0];if(null!==a)return a;if(!r[0]){const s=this.ComputeDiffRecursive(t,l,e,h,r);let o=[];return o=r[0]?[new DiffChange(l+1,i-(l+1)+1,h+1,n-(h+1)+1)]:this.ComputeDiffRecursive(l+1,i,h+1,n,r),this.ConcatenateChanges(s,o)}return[new DiffChange(t,i-t+1,e,n-e+1)]}WALKTRACE(t,i,e,n,r,s,o,a,l,h,g,d,f,m,u,c,S,_){let E=null,C=null,y=new DiffChangeHelper,A=i,L=e,p=f[0]-c[0]-n,D=-1073741824,w=this.m_forwardHistory.length-1;do{const i=p+t;i===A||i<L&&l[i-1]<l[i+1]?(g=l[i+1],m=g-p-n,g<D&&y.MarkNextChange(),D=g,y.AddModifiedElement(g+1,m),p=i+1-t):(g=l[i-1]+1,m=g-p-n,g<D&&y.MarkNextChange(),D=g-1,y.AddOriginalElement(g,m+1),p=i-1-t),w>=0&&(l=this.m_forwardHistory[w],t=l[0],A=1,L=l.length-1)}while(--w>=-1);if(E=y.getReverseChanges(),_[0]){let t=f[0]+1,i=c[0]+1;if(null!==E&&E.length>0){const e=E[E.length-1];t=Math.max(t,e.getOriginalEnd()),i=Math.max(i,e.getModifiedEnd())}C=[new DiffChange(t,d-t+1,i,u-i+1)]}else{y=new DiffChangeHelper,A=s,L=o,p=f[0]-c[0]-a,D=1073741824,w=S?this.m_reverseHistory.length-1:this.m_reverseHistory.length-2;do{const t=p+r;t===A||t<L&&h[t-1]>=h[t+1]?(g=h[t+1]-1,m=g-p-a,g>D&&y.MarkNextChange(),D=g+1,y.AddOriginalElement(g+1,m+1),p=t+1-r):(g=h[t-1],m=g-p-a,g>D&&y.MarkNextChange(),D=g,y.AddModifiedElement(g+1,m+1),p=t-1-r),w>=0&&(h=this.m_reverseHistory[w],r=h[0],A=1,L=h.length-1)}while(--w>=-1);C=y.getChanges()}return this.ConcatenateChanges(E,C)}ComputeRecursionPoint(t,i,e,n,r,s,o){let a=0,l=0,h=0,g=0,d=0,f=0;t--,e--,r[0]=0,s[0]=0,this.m_forwardHistory=[],this.m_reverseHistory=[];const m=i-t+(n-e),u=m+1,c=new Int32Array(u),S=new Int32Array(u),_=n-e,E=i-t,C=t-e,y=i-n,A=E-_,L=A%2===0;c[_]=t,S[E]=i,o[0]=!1;for(let p=1;p<=m/2+1;p++){let m=0,A=0;h=this.ClipDiagonalBound(_-p,p,_,u),g=this.ClipDiagonalBound(_+p,p,_,u);for(let t=h;t<=g;t+=2){a=t===h||t<g&&c[t-1]<c[t+1]?c[t+1]:c[t-1]+1,l=a-(t-_)-C;const e=a;while(a<i&&l<n&&this.ElementsAreEqual(a+1,l+1))a++,l++;if(c[t]=a,a+l>m+A&&(m=a,A=l),!L&&Math.abs(t-E)<=p-1&&a>=S[t])return r[0]=a,s[0]=l,e<=S[t]&&p<=1448?this.WALKTRACE(_,h,g,C,E,d,f,y,c,S,a,i,r,l,n,s,L,o):null}const D=(m-t+(A-e)-p)/2;if(null!==this.ContinueProcessingPredicate&&!this.ContinueProcessingPredicate(m,D))return o[0]=!0,r[0]=m,s[0]=A,D>0&&p<=1448?this.WALKTRACE(_,h,g,C,E,d,f,y,c,S,a,i,r,l,n,s,L,o):(t++,e++,[new DiffChange(t,i-t+1,e,n-e+1)]);d=this.ClipDiagonalBound(E-p,p,E,u),f=this.ClipDiagonalBound(E+p,p,E,u);for(let u=d;u<=f;u+=2){a=u===d||u<f&&S[u-1]>=S[u+1]?S[u+1]-1:S[u-1],l=a-(u-E)-y;const m=a;while(a>t&&l>e&&this.ElementsAreEqual(a,l))a--,l--;if(S[u]=a,L&&Math.abs(u-_)<=p&&a<=c[u])return r[0]=a,s[0]=l,m>=c[u]&&p<=1448?this.WALKTRACE(_,h,g,C,E,d,f,y,c,S,a,i,r,l,n,s,L,o):null}if(p<=1447){let t=new Int32Array(g-h+2);t[0]=_-h+1,MyArray.Copy2(c,h,t,1,g-h+1),this.m_forwardHistory.push(t),t=new Int32Array(f-d+2),t[0]=E-d+1,MyArray.Copy2(S,d,t,1,f-d+1),this.m_reverseHistory.push(t)}}return this.WALKTRACE(_,h,g,C,E,d,f,y,c,S,a,i,r,l,n,s,L,o)}PrettifyChanges(t){for(let i=0;i<t.length;i++){const e=t[i],n=i<t.length-1?t[i+1].originalStart:this._originalElementsOrHash.length,r=i<t.length-1?t[i+1].modifiedStart:this._modifiedElementsOrHash.length,s=e.originalLength>0,o=e.modifiedLength>0;while(e.originalStart+e.originalLength<n&&e.modifiedStart+e.modifiedLength<r&&(!s||this.OriginalElementsAreEqual(e.originalStart,e.originalStart+e.originalLength))&&(!o||this.ModifiedElementsAreEqual(e.modifiedStart,e.modifiedStart+e.modifiedLength))){const t=this.ElementsAreStrictEqual(e.originalStart,e.modifiedStart),i=this.ElementsAreStrictEqual(e.originalStart+e.originalLength,e.modifiedStart+e.modifiedLength);if(i&&!t)break;e.originalStart++,e.modifiedStart++}let a=[null];i<t.length-1&&this.ChangesOverlap(t[i],t[i+1],a)&&(t[i]=a[0],t.splice(i+1,1),i--)}for(let i=t.length-1;i>=0;i--){const e=t[i];let n=0,r=0;if(i>0){const e=t[i-1];n=e.originalStart+e.originalLength,r=e.modifiedStart+e.modifiedLength}const s=e.originalLength>0,o=e.modifiedLength>0;let a=0,l=this._boundaryScore(e.originalStart,e.originalLength,e.modifiedStart,e.modifiedLength);for(let t=1;;t++){const i=e.originalStart-t,h=e.modifiedStart-t;if(i<n||h<r)break;if(s&&!this.OriginalElementsAreEqual(i,i+e.originalLength))break;if(o&&!this.ModifiedElementsAreEqual(h,h+e.modifiedLength))break;const g=i===n&&h===r,d=(g?5:0)+this._boundaryScore(i,e.originalLength,h,e.modifiedLength);d>l&&(l=d,a=t)}e.originalStart-=a,e.modifiedStart-=a;const h=[null];i>0&&this.ChangesOverlap(t[i-1],t[i],h)&&(t[i-1]=h[0],t.splice(i,1),i++)}if(this._hasStrings)for(let i=1,e=t.length;i<e;i++){const e=t[i-1],n=t[i],r=n.originalStart-e.originalStart-e.originalLength,s=e.originalStart,o=n.originalStart+n.originalLength,a=o-s,l=e.modifiedStart,h=n.modifiedStart+n.modifiedLength,g=h-l;if(r<5&&a<20&&g<20){const t=this._findBetterContiguousSequence(s,a,l,g,r);if(t){const[i,s]=t;i===e.originalStart+e.originalLength&&s===e.modifiedStart+e.modifiedLength||(e.originalLength=i-e.originalStart,e.modifiedLength=s-e.modifiedStart,n.originalStart=i+r,n.modifiedStart=s+r,n.originalLength=o-n.originalStart,n.modifiedLength=h-n.modifiedStart)}}}return t}_findBetterContiguousSequence(t,i,e,n,r){if(i<r||n<r)return null;const s=t+i-r+1,o=e+n-r+1;let a=0,l=0,h=0;for(let g=t;g<s;g++)for(let t=e;t<o;t++){const i=this._contiguousSequenceScore(g,t,r);i>0&&i>a&&(a=i,l=g,h=t)}return a>0?[l,h]:null}_contiguousSequenceScore(t,i,e){let n=0;for(let r=0;r<e;r++){if(!this.ElementsAreEqual(t+r,i+r))return 0;n+=this._originalStringElements[t+r].length}return n}_OriginalIsBoundary(t){return t<=0||t>=this._originalElementsOrHash.length-1||this._hasStrings&&/^\s*$/.test(this._originalStringElements[t])}_OriginalRegionIsBoundary(t,i){if(this._OriginalIsBoundary(t)||this._OriginalIsBoundary(t-1))return!0;if(i>0){const e=t+i;if(this._OriginalIsBoundary(e-1)||this._OriginalIsBoundary(e))return!0}return!1}_ModifiedIsBoundary(t){return t<=0||t>=this._modifiedElementsOrHash.length-1||this._hasStrings&&/^\s*$/.test(this._modifiedStringElements[t])}_ModifiedRegionIsBoundary(t,i){if(this._ModifiedIsBoundary(t)||this._ModifiedIsBoundary(t-1))return!0;if(i>0){const e=t+i;if(this._ModifiedIsBoundary(e-1)||this._ModifiedIsBoundary(e))return!0}return!1}_boundaryScore(t,i,e,n){const r=this._OriginalRegionIsBoundary(t,i)?1:0,s=this._ModifiedRegionIsBoundary(e,n)?1:0;return r+s}ConcatenateChanges(t,i){let e=[];if(0===t.length||0===i.length)return i.length>0?i:t;if(this.ChangesOverlap(t[t.length-1],i[0],e)){const n=new Array(t.length+i.length-1);return MyArray.Copy(t,0,n,0,t.length-1),n[t.length-1]=e[0],MyArray.Copy(i,1,n,t.length,i.length-1),n}{const e=new Array(t.length+i.length);return MyArray.Copy(t,0,e,0,t.length),MyArray.Copy(i,0,e,t.length,i.length),e}}ChangesOverlap(t,i,e){if(Debug.Assert(t.originalStart<=i.originalStart,"Left change is not less than or equal to right change"),Debug.Assert(t.modifiedStart<=i.modifiedStart,"Left change is not less than or equal to right change"),t.originalStart+t.originalLength>=i.originalStart||t.modifiedStart+t.modifiedLength>=i.modifiedStart){const n=t.originalStart;let r=t.originalLength;const s=t.modifiedStart;let o=t.modifiedLength;return t.originalStart+t.originalLength>=i.originalStart&&(r=i.originalStart+i.originalLength-t.originalStart),t.modifiedStart+t.modifiedLength>=i.modifiedStart&&(o=i.modifiedStart+i.modifiedLength-t.modifiedStart),e[0]=new DiffChange(n,r,s,o),!0}return e[0]=null,!1}ClipDiagonalBound(t,i,e,n){if(t>=0&&t<n)return t;const r=e,s=n-e-1,o=i%2===0;if(t<0){const t=r%2===0;return o===t?0:1}{const t=s%2===0;return o===t?n-1:n-2}}}