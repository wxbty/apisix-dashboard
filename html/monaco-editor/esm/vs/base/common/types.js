export function isArray(t){return Array.isArray(t)}export function isString(t){return"string"===typeof t}export function isObject(t){return"object"===typeof t&&null!==t&&!Array.isArray(t)&&!(t instanceof RegExp)&&!(t instanceof Date)}export function isNumber(t){return"number"===typeof t&&!isNaN(t)}export function isBoolean(t){return!0===t||!1===t}export function isUndefined(t){return"undefined"===typeof t}export function isDefined(t){return!isUndefinedOrNull(t)}export function isUndefinedOrNull(t){return isUndefined(t)||null===t}export function assertType(t,e){if(!t)throw new Error(e?`Unexpected type, expected '${e}'`:"Unexpected type")}export function assertIsDefined(t){if(isUndefinedOrNull(t))throw new Error("Assertion Failed: argument is undefined or null");return t}export function isFunction(t){return"function"===typeof t}export function validateConstraints(t,e){const n=Math.min(t.length,e.length);for(let r=0;r<n;r++)validateConstraint(t[r],e[r])}export function validateConstraint(t,e){if(isString(e)){if(typeof t!==e)throw new Error(`argument does not match constraint: typeof ${e}`)}else if(isFunction(e)){try{if(t instanceof e)return}catch(n){}if(!isUndefinedOrNull(t)&&t.constructor===e)return;if(1===e.length&&!0===e.call(void 0,t))return;throw new Error("argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true")}}export function getAllPropertyNames(t){let e=[],n=Object.getPrototypeOf(t);while(Object.prototype!==n)e=e.concat(Object.getOwnPropertyNames(n)),n=Object.getPrototypeOf(n);return e}export function getAllMethodNames(t){const e=[];for(const n of getAllPropertyNames(t))"function"===typeof t[n]&&e.push(n);return e}export function createProxyObject(t,e){const n=t=>function(){const n=Array.prototype.slice.call(arguments,0);return e(t,n)};let r={};for(const o of t)r[o]=n(o);return r}export function withNullAsUndefined(t){return null===t?void 0:t}export function assertNever(t,e="Unreachable"){throw new Error(e)}