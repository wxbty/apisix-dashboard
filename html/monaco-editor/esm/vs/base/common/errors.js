export class ErrorHandler{constructor(){this.listeners=[],this.unexpectedErrorHandler=function(r){setTimeout((()=>{if(r.stack)throw new Error(r.message+"\n\n"+r.stack);throw r}),0)}}emit(r){this.listeners.forEach((e=>{e(r)}))}onUnexpectedError(r){this.unexpectedErrorHandler(r),this.emit(r)}onUnexpectedExternalError(r){this.unexpectedErrorHandler(r)}}export const errorHandler=new ErrorHandler;export function onUnexpectedError(r){isCancellationError(r)||errorHandler.onUnexpectedError(r)}export function onUnexpectedExternalError(r){isCancellationError(r)||errorHandler.onUnexpectedExternalError(r)}export function transformErrorForSerialization(r){if(r instanceof Error){let{name:e,message:n}=r;const t=r.stacktrace||r.stack;return{$isError:!0,name:e,message:n,stack:t}}return r}const canceledName="Canceled";export function isCancellationError(r){return r instanceof CancellationError||r instanceof Error&&r.name===canceledName&&r.message===canceledName}export class CancellationError extends Error{constructor(){super(canceledName),this.name=this.message}}export function canceled(){const r=new Error(canceledName);return r.name=r.message,r}export function illegalArgument(r){return r?new Error(`Illegal argument: ${r}`):new Error("Illegal argument")}export function illegalState(r){return r?new Error(`Illegal state: ${r}`):new Error("Illegal state")}export class NotSupportedError extends Error{constructor(r){super("NotSupported"),r&&(this.message=r)}}