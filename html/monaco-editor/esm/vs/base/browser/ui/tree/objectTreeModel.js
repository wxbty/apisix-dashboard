import{IndexTreeModel}from"./indexTreeModel.js";import{TreeError}from"./tree.js";import{Iterable}from"../../../common/iterator.js";export class ObjectTreeModel{constructor(e,t,o={}){this.user=e,this.rootRef=null,this.nodes=new Map,this.nodesByIdentity=new Map,this.model=new IndexTreeModel(e,t,null,o),this.onDidSplice=this.model.onDidSplice,this.onDidChangeCollapseState=this.model.onDidChangeCollapseState,this.onDidChangeRenderNodeCount=this.model.onDidChangeRenderNodeCount,o.sorter&&(this.sorter={compare(e,t){return o.sorter.compare(e.element,t.element)}}),this.identityProvider=o.identityProvider}setChildren(e,t=Iterable.empty(),o={}){const n=this.getElementLocation(e);this._setChildren(n,this.preserveCollapseState(t),o)}_setChildren(e,t=Iterable.empty(),o){const n=new Set,i=new Set,s=e=>{var t;if(null===e.element)return;const s=e;if(n.add(s.element),this.nodes.set(s.element,s),this.identityProvider){const e=this.identityProvider.getId(s.element).toString();i.add(e),this.nodesByIdentity.set(e,s)}null===(t=o.onDidCreateNode)||void 0===t||t.call(o,s)},r=e=>{var t;if(null===e.element)return;const s=e;if(n.has(s.element)||this.nodes.delete(s.element),this.identityProvider){const e=this.identityProvider.getId(s.element).toString();i.has(e)||this.nodesByIdentity.delete(e)}null===(t=o.onDidDeleteNode)||void 0===t||t.call(o,s)};this.model.splice([...e,0],Number.MAX_VALUE,t,Object.assign(Object.assign({},o),{onDidCreateNode:s,onDidDeleteNode:r}))}preserveCollapseState(e=Iterable.empty()){return this.sorter&&(e=[...e].sort(this.sorter.compare.bind(this.sorter))),Iterable.map(e,(e=>{let t=this.nodes.get(e.element);if(!t&&this.identityProvider){const o=this.identityProvider.getId(e.element).toString();t=this.nodesByIdentity.get(o)}if(!t)return Object.assign(Object.assign({},e),{children:this.preserveCollapseState(e.children)});const o="boolean"===typeof e.collapsible?e.collapsible:t.collapsible,n="undefined"!==typeof e.collapsed?e.collapsed:t.collapsed;return Object.assign(Object.assign({},e),{collapsible:o,collapsed:n,children:this.preserveCollapseState(e.children)})}))}rerender(e){const t=this.getElementLocation(e);this.model.rerender(t)}getFirstElementChild(e=null){const t=this.getElementLocation(e);return this.model.getFirstElementChild(t)}has(e){return this.nodes.has(e)}getListIndex(e){const t=this.getElementLocation(e);return this.model.getListIndex(t)}getListRenderCount(e){const t=this.getElementLocation(e);return this.model.getListRenderCount(t)}isCollapsible(e){const t=this.getElementLocation(e);return this.model.isCollapsible(t)}setCollapsible(e,t){const o=this.getElementLocation(e);return this.model.setCollapsible(o,t)}isCollapsed(e){const t=this.getElementLocation(e);return this.model.isCollapsed(t)}setCollapsed(e,t,o){const n=this.getElementLocation(e);return this.model.setCollapsed(n,t,o)}expandTo(e){const t=this.getElementLocation(e);this.model.expandTo(t)}refilter(){this.model.refilter()}getNode(e=null){if(null===e)return this.model.getNode(this.model.rootRef);const t=this.nodes.get(e);if(!t)throw new TreeError(this.user,`Tree element not found: ${e}`);return t}getNodeLocation(e){return e.element}getParentNodeLocation(e){if(null===e)throw new TreeError(this.user,"Invalid getParentNodeLocation call");const t=this.nodes.get(e);if(!t)throw new TreeError(this.user,`Tree element not found: ${e}`);const o=this.model.getNodeLocation(t),n=this.model.getParentNodeLocation(o),i=this.model.getNode(n);return i.element}getElementLocation(e){if(null===e)return[];const t=this.nodes.get(e);if(!t)throw new TreeError(this.user,`Tree element not found: ${e}`);return this.model.getNodeLocation(t)}}