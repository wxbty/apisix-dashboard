import{ObjectTreeModel}from"./objectTreeModel.js";import{TreeError,WeakMapper}from"./tree.js";import{Event}from"../../../common/event.js";import{Iterable}from"../../../common/iterator.js";function noCompress(e){const t=[e.element],s=e.incompressible||!1;return{element:{elements:t,incompressible:s},children:Iterable.map(Iterable.from(e.children),noCompress),collapsible:e.collapsible,collapsed:e.collapsed}}export function compress(e){const t=[e.element],s=e.incompressible||!1;let n,r;while(1){if([r,n]=Iterable.consume(Iterable.from(e.children),2),1!==r.length)break;if(r[0].incompressible)break;e=r[0],t.push(e.element)}return{element:{elements:t,incompressible:s},children:Iterable.map(Iterable.concat(r,n),compress),collapsible:e.collapsible,collapsed:e.collapsed}}function _decompress(e,t=0){let s;return s=t<e.element.elements.length-1?[_decompress(e,t+1)]:Iterable.map(Iterable.from(e.children),(e=>_decompress(e,0))),0===t&&e.element.incompressible?{element:e.element.elements[t],children:s,incompressible:!0,collapsible:e.collapsible,collapsed:e.collapsed}:{element:e.element.elements[t],children:s,collapsible:e.collapsible,collapsed:e.collapsed}}export function decompress(e){return _decompress(e,0)}function splice(e,t,s){return e.element===t?Object.assign(Object.assign({},e),{children:s}):Object.assign(Object.assign({},e),{children:Iterable.map(Iterable.from(e.children),(e=>splice(e,t,s)))})}const wrapIdentityProvider=e=>({getId(t){return t.elements.map((t=>e.getId(t).toString())).join("\0")}});export class CompressedObjectTreeModel{constructor(e,t,s={}){this.user=e,this.rootRef=null,this.nodes=new Map,this.model=new ObjectTreeModel(e,t,s),this.enabled="undefined"===typeof s.compressionEnabled||s.compressionEnabled,this.identityProvider=s.identityProvider}get onDidSplice(){return this.model.onDidSplice}get onDidChangeCollapseState(){return this.model.onDidChangeCollapseState}get onDidChangeRenderNodeCount(){return this.model.onDidChangeRenderNodeCount}setChildren(e,t=Iterable.empty(),s){const n=s.diffIdentityProvider&&wrapIdentityProvider(s.diffIdentityProvider);if(null===e){const e=Iterable.map(t,this.enabled?compress:noCompress);return void this._setChildren(null,e,{diffIdentityProvider:n,diffDepth:1/0})}const r=this.nodes.get(e);if(!r)throw new Error("Unknown compressed tree node");const o=this.model.getNode(r),l=this.model.getParentNodeLocation(r),i=this.model.getNode(l),d=decompress(o),p=splice(d,e,t),m=(this.enabled?compress:noCompress)(p),a=i.children.map((e=>e===o?m:e));this._setChildren(i.element,a,{diffIdentityProvider:n,diffDepth:o.depth-i.depth})}setCompressionEnabled(e){if(e===this.enabled)return;this.enabled=e;const t=this.model.getNode(),s=t.children,n=Iterable.map(s,decompress),r=Iterable.map(n,e?compress:noCompress);this._setChildren(null,r,{diffIdentityProvider:this.identityProvider,diffDepth:1/0})}_setChildren(e,t,s){const n=new Set,r=e=>{for(const t of e.element.elements)n.add(t),this.nodes.set(t,e.element)},o=e=>{for(const t of e.element.elements)n.has(t)||this.nodes.delete(t)};this.model.setChildren(e,t,Object.assign(Object.assign({},s),{onDidCreateNode:r,onDidDeleteNode:o}))}has(e){return this.nodes.has(e)}getListIndex(e){const t=this.getCompressedNode(e);return this.model.getListIndex(t)}getListRenderCount(e){const t=this.getCompressedNode(e);return this.model.getListRenderCount(t)}getNode(e){if("undefined"===typeof e)return this.model.getNode();const t=this.getCompressedNode(e);return this.model.getNode(t)}getNodeLocation(e){const t=this.model.getNodeLocation(e);return null===t?null:t.elements[t.elements.length-1]}getParentNodeLocation(e){const t=this.getCompressedNode(e),s=this.model.getParentNodeLocation(t);return null===s?null:s.elements[s.elements.length-1]}getFirstElementChild(e){const t=this.getCompressedNode(e);return this.model.getFirstElementChild(t)}isCollapsible(e){const t=this.getCompressedNode(e);return this.model.isCollapsible(t)}setCollapsible(e,t){const s=this.getCompressedNode(e);return this.model.setCollapsible(s,t)}isCollapsed(e){const t=this.getCompressedNode(e);return this.model.isCollapsed(t)}setCollapsed(e,t,s){const n=this.getCompressedNode(e);return this.model.setCollapsed(n,t,s)}expandTo(e){const t=this.getCompressedNode(e);this.model.expandTo(t)}rerender(e){const t=this.getCompressedNode(e);this.model.rerender(t)}refilter(){this.model.refilter()}getCompressedNode(e){if(null===e)return null;const t=this.nodes.get(e);if(!t)throw new TreeError(this.user,`Tree element not found: ${e}`);return t}}export const DefaultElementMapper=e=>e[e.length-1];class CompressedTreeNodeWrapper{constructor(e,t){this.unwrapper=e,this.node=t}get element(){return null===this.node.element?null:this.unwrapper(this.node.element)}get children(){return this.node.children.map((e=>new CompressedTreeNodeWrapper(this.unwrapper,e)))}get depth(){return this.node.depth}get visibleChildrenCount(){return this.node.visibleChildrenCount}get visibleChildIndex(){return this.node.visibleChildIndex}get collapsible(){return this.node.collapsible}get collapsed(){return this.node.collapsed}get visible(){return this.node.visible}get filterData(){return this.node.filterData}}function mapList(e,t){return{splice(s,n,r){t.splice(s,n,r.map((t=>e.map(t))))},updateElementHeight(e,s){t.updateElementHeight(e,s)}}}function mapOptions(e,t){return Object.assign(Object.assign({},t),{identityProvider:t.identityProvider&&{getId(s){return t.identityProvider.getId(e(s))}},sorter:t.sorter&&{compare(e,s){return t.sorter.compare(e.elements[0],s.elements[0])}},filter:t.filter&&{filter(s,n){return t.filter.filter(e(s),n)}}})}export class CompressibleObjectTreeModel{constructor(e,t,s={}){this.rootRef=null,this.elementMapper=s.elementMapper||DefaultElementMapper;const n=e=>this.elementMapper(e.elements);this.nodeMapper=new WeakMapper((e=>new CompressedTreeNodeWrapper(n,e))),this.model=new CompressedObjectTreeModel(e,mapList(this.nodeMapper,t),mapOptions(n,s))}get onDidSplice(){return Event.map(this.model.onDidSplice,(({insertedNodes:e,deletedNodes:t})=>({insertedNodes:e.map((e=>this.nodeMapper.map(e))),deletedNodes:t.map((e=>this.nodeMapper.map(e)))})))}get onDidChangeCollapseState(){return Event.map(this.model.onDidChangeCollapseState,(({node:e,deep:t})=>({node:this.nodeMapper.map(e),deep:t})))}get onDidChangeRenderNodeCount(){return Event.map(this.model.onDidChangeRenderNodeCount,(e=>this.nodeMapper.map(e)))}setChildren(e,t=Iterable.empty(),s={}){this.model.setChildren(e,t,s)}setCompressionEnabled(e){this.model.setCompressionEnabled(e)}has(e){return this.model.has(e)}getListIndex(e){return this.model.getListIndex(e)}getListRenderCount(e){return this.model.getListRenderCount(e)}getNode(e){return this.nodeMapper.map(this.model.getNode(e))}getNodeLocation(e){return e.element}getParentNodeLocation(e){return this.model.getParentNodeLocation(e)}getFirstElementChild(e){const t=this.model.getFirstElementChild(e);return null===t||"undefined"===typeof t?t:this.elementMapper(t.elements)}isCollapsible(e){return this.model.isCollapsible(e)}setCollapsible(e,t){return this.model.setCollapsible(e,t)}isCollapsed(e){return this.model.isCollapsed(e)}setCollapsed(e,t,s){return this.model.setCollapsed(e,t,s)}expandTo(e){return this.model.expandTo(e)}rerender(e){return this.model.rerender(e)}refilter(){return this.model.refilter()}getCompressedTreeNode(e=null){return this.model.getNode(e)}}