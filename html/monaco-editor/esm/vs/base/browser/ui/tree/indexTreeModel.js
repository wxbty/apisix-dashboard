import{TreeError}from"./tree.js";import{splice,tail2}from"../../../common/arrays.js";import{Delayer,MicrotaskDelay}from"../../../common/async.js";import{LcsDiff}from"../../../common/diff/diff.js";import{Emitter,EventBufferer}from"../../../common/event.js";import{Iterable}from"../../../common/iterator.js";export function isFilterResult(e){return"object"===typeof e&&"visibility"in e&&"data"in e}export function getVisibleState(e){switch(e){case!0:return 1;case!1:return 0;default:return e}}function isCollapsibleStateUpdate(e){return"boolean"===typeof e.collapsible}export class IndexTreeModel{constructor(e,t,i,l={}){this.user=e,this.list=t,this.rootRef=[],this.eventBufferer=new EventBufferer,this._onDidChangeCollapseState=new Emitter,this.onDidChangeCollapseState=this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event),this._onDidChangeRenderNodeCount=new Emitter,this.onDidChangeRenderNodeCount=this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event),this._onDidSplice=new Emitter,this.onDidSplice=this._onDidSplice.event,this.refilterDelayer=new Delayer(MicrotaskDelay),this.collapseByDefault="undefined"!==typeof l.collapseByDefault&&l.collapseByDefault,this.filter=l.filter,this.autoExpandSingleChildren="undefined"!==typeof l.autoExpandSingleChildren&&l.autoExpandSingleChildren,this.root={parent:void 0,element:i,children:[],depth:0,visibleChildrenCount:0,visibleChildIndex:-1,collapsible:!1,collapsed:!1,renderNodeCount:0,visibility:1,visible:!0,filterData:void 0}}splice(e,t,i=Iterable.empty(),l={}){if(0===e.length)throw new TreeError(this.user,"Invalid tree location");l.diffIdentityProvider?this.spliceSmart(l.diffIdentityProvider,e,t,i,l):this.spliceSimple(e,t,i,l)}spliceSmart(e,t,i,l,r,n){var o;void 0===l&&(l=Iterable.empty()),void 0===n&&(n=null!==(o=r.diffDepth)&&void 0!==o?o:0);const{parentNode:s}=this.getParentNodeWithListIndex(t);if(!s.lastDiffIds)return this.spliceSimple(t,i,l,r);const d=[...l],a=t[t.length-1],h=new LcsDiff({getElements:()=>s.lastDiffIds},{getElements:()=>[...s.children.slice(0,a),...d,...s.children.slice(a+i)].map((t=>e.getId(t.element).toString()))}).ComputeDiff(!1);if(h.quitEarly)return s.lastDiffIds=void 0,this.spliceSimple(t,i,d,r);const c=t.slice(0,-1),p=(t,i,l)=>{if(n>0)for(let o=0;o<l;o++)t--,i--,this.spliceSmart(e,[...c,t,0],Number.MAX_SAFE_INTEGER,d[i].children,r,n-1)};let f=Math.min(s.children.length,a+i),u=d.length;for(const C of h.changes.sort(((e,t)=>t.originalStart-e.originalStart)))p(f,u,f-(C.originalStart+C.originalLength)),f=C.originalStart,u=C.modifiedStart-a,this.spliceSimple([...c,f],C.originalLength,Iterable.slice(d,u,u+C.modifiedLength),r);p(f,u,f)}spliceSimple(e,t,i=Iterable.empty(),{onDidCreateNode:l,onDidDeleteNode:r,diffIdentityProvider:n}){const{parentNode:o,listIndex:s,revealed:d,visible:a}=this.getParentNodeWithListIndex(e),h=[],c=Iterable.map(i,(e=>this.createTreeNode(e,o,o.visible?1:0,d,h,l))),p=e[e.length-1],f=o.children.length>0;let u=0;for(let S=p;S>=0&&S<o.children.length;S--){const e=o.children[S];if(e.visible){u=e.visibleChildIndex;break}}const C=[];let g=0,v=0;for(const S of c)C.push(S),v+=S.renderNodeCount,S.visible&&(S.visibleChildIndex=u+g++);const b=splice(o.children,p,t,C);n?o.lastDiffIds?splice(o.lastDiffIds,p,t,C.map((e=>n.getId(e.element).toString()))):o.lastDiffIds=o.children.map((e=>n.getId(e.element).toString())):o.lastDiffIds=void 0;let N=0;for(const S of b)S.visible&&N++;if(0!==N)for(let S=p+C.length;S<o.children.length;S++){const e=o.children[S];e.visible&&(e.visibleChildIndex-=N)}if(o.visibleChildrenCount+=g-N,d&&a){const e=b.reduce(((e,t)=>e+(t.visible?t.renderNodeCount:0)),0);this._updateAncestorsRenderNodeCount(o,v-e),this.list.splice(s,e,h)}if(b.length>0&&r){const e=t=>{r(t),t.children.forEach(e)};b.forEach(e)}const m=o.children.length>0;f!==m&&this.setCollapsible(e.slice(0,-1),m),this._onDidSplice.fire({insertedNodes:C,deletedNodes:b});let I=o;while(I){if(2===I.visibility){this.refilterDelayer.trigger((()=>this.refilter()));break}I=I.parent}}rerender(e){if(0===e.length)throw new TreeError(this.user,"Invalid tree location");const{node:t,listIndex:i,revealed:l}=this.getTreeNodeWithListIndex(e);t.visible&&l&&this.list.splice(i,1,[t])}has(e){return this.hasTreeNode(e)}getListIndex(e){const{listIndex:t,visible:i,revealed:l}=this.getTreeNodeWithListIndex(e);return i&&l?t:-1}getListRenderCount(e){return this.getTreeNode(e).renderNodeCount}isCollapsible(e){return this.getTreeNode(e).collapsible}setCollapsible(e,t){const i=this.getTreeNode(e);"undefined"===typeof t&&(t=!i.collapsible);const l={collapsible:t};return this.eventBufferer.bufferEvents((()=>this._setCollapseState(e,l)))}isCollapsed(e){return this.getTreeNode(e).collapsed}setCollapsed(e,t,i){const l=this.getTreeNode(e);"undefined"===typeof t&&(t=!l.collapsed);const r={collapsed:t,recursive:i||!1};return this.eventBufferer.bufferEvents((()=>this._setCollapseState(e,r)))}_setCollapseState(e,t){const{node:i,listIndex:l,revealed:r}=this.getTreeNodeWithListIndex(e),n=this._setListNodeCollapseState(i,l,r,t);if(i!==this.root&&this.autoExpandSingleChildren&&n&&!isCollapsibleStateUpdate(t)&&i.collapsible&&!i.collapsed&&!t.recursive){let l=-1;for(let e=0;e<i.children.length;e++){const t=i.children[e];if(t.visible){if(l>-1){l=-1;break}l=e}}l>-1&&this._setCollapseState([...e,l],t)}return n}_setListNodeCollapseState(e,t,i,l){const r=this._setNodeCollapseState(e,l,!1);if(!i||!e.visible||!r)return r;const n=e.renderNodeCount,o=this.updateNodeAfterCollapseChange(e),s=n-(-1===t?0:1);return this.list.splice(t+1,s,o.slice(1)),r}_setNodeCollapseState(e,t,i){let l;if(e===this.root?l=!1:(isCollapsibleStateUpdate(t)?(l=e.collapsible!==t.collapsible,e.collapsible=t.collapsible):e.collapsible?(l=e.collapsed!==t.collapsed,e.collapsed=t.collapsed):l=!1,l&&this._onDidChangeCollapseState.fire({node:e,deep:i})),!isCollapsibleStateUpdate(t)&&t.recursive)for(const r of e.children)l=this._setNodeCollapseState(r,t,!0)||l;return l}expandTo(e){this.eventBufferer.bufferEvents((()=>{let t=this.getTreeNode(e);while(t.parent)t=t.parent,e=e.slice(0,e.length-1),t.collapsed&&this._setCollapseState(e,{collapsed:!1,recursive:!1})}))}refilter(){const e=this.root.renderNodeCount,t=this.updateNodeAfterFilterChange(this.root);this.list.splice(0,e,t),this.refilterDelayer.cancel()}createTreeNode(e,t,i,l,r,n){const o={parent:t,element:e.element,children:[],depth:t.depth+1,visibleChildrenCount:0,visibleChildIndex:-1,collapsible:"boolean"===typeof e.collapsible?e.collapsible:"undefined"!==typeof e.collapsed,collapsed:"undefined"===typeof e.collapsed?this.collapseByDefault:e.collapsed,renderNodeCount:1,visibility:1,visible:!0,filterData:void 0},s=this._filterNode(o,i);o.visibility=s,l&&r.push(o);const d=e.children||Iterable.empty(),a=l&&0!==s&&!o.collapsed,h=Iterable.map(d,(e=>this.createTreeNode(e,o,s,a,r,n)));let c=0,p=1;for(const f of h)o.children.push(f),p+=f.renderNodeCount,f.visible&&(f.visibleChildIndex=c++);return o.collapsible=o.collapsible||o.children.length>0,o.visibleChildrenCount=c,o.visible=2===s?c>0:1===s,o.visible?o.collapsed||(o.renderNodeCount=p):(o.renderNodeCount=0,l&&r.pop()),n&&n(o),o}updateNodeAfterCollapseChange(e){const t=e.renderNodeCount,i=[];return this._updateNodeAfterCollapseChange(e,i),this._updateAncestorsRenderNodeCount(e.parent,i.length-t),i}_updateNodeAfterCollapseChange(e,t){if(!1===e.visible)return 0;if(t.push(e),e.renderNodeCount=1,!e.collapsed)for(const i of e.children)e.renderNodeCount+=this._updateNodeAfterCollapseChange(i,t);return this._onDidChangeRenderNodeCount.fire(e),e.renderNodeCount}updateNodeAfterFilterChange(e){const t=e.renderNodeCount,i=[];return this._updateNodeAfterFilterChange(e,e.visible?1:0,i),this._updateAncestorsRenderNodeCount(e.parent,i.length-t),i}_updateNodeAfterFilterChange(e,t,i,l=!0){let r;if(e!==this.root){if(r=this._filterNode(e,t),0===r)return e.visible=!1,e.renderNodeCount=0,!1;l&&i.push(e)}const n=i.length;e.renderNodeCount=e===this.root?0:1;let o=!1;if(e.collapsed&&0===r)e.visibleChildrenCount=0;else{let t=0;for(const n of e.children)o=this._updateNodeAfterFilterChange(n,r,i,l&&!e.collapsed)||o,n.visible&&(n.visibleChildIndex=t++);e.visibleChildrenCount=t}return e!==this.root&&(e.visible=2===r?o:1===r,e.visibility=r),e.visible?e.collapsed||(e.renderNodeCount+=i.length-n):(e.renderNodeCount=0,l&&i.pop()),this._onDidChangeRenderNodeCount.fire(e),e.visible}_updateAncestorsRenderNodeCount(e,t){if(0!==t)while(e)e.renderNodeCount+=t,this._onDidChangeRenderNodeCount.fire(e),e=e.parent}_filterNode(e,t){const i=this.filter?this.filter.filter(e.element,t):1;return"boolean"===typeof i?(e.filterData=void 0,i?1:0):isFilterResult(i)?(e.filterData=i.data,getVisibleState(i.visibility)):(e.filterData=void 0,getVisibleState(i))}hasTreeNode(e,t=this.root){if(!e||0===e.length)return!0;const[i,...l]=e;return!(i<0||i>t.children.length)&&this.hasTreeNode(l,t.children[i])}getTreeNode(e,t=this.root){if(!e||0===e.length)return t;const[i,...l]=e;if(i<0||i>t.children.length)throw new TreeError(this.user,"Invalid tree location");return this.getTreeNode(l,t.children[i])}getTreeNodeWithListIndex(e){if(0===e.length)return{node:this.root,listIndex:-1,revealed:!0,visible:!1};const{parentNode:t,listIndex:i,revealed:l,visible:r}=this.getParentNodeWithListIndex(e),n=e[e.length-1];if(n<0||n>t.children.length)throw new TreeError(this.user,"Invalid tree location");const o=t.children[n];return{node:o,listIndex:i,revealed:l,visible:r&&o.visible}}getParentNodeWithListIndex(e,t=this.root,i=0,l=!0,r=!0){const[n,...o]=e;if(n<0||n>t.children.length)throw new TreeError(this.user,"Invalid tree location");for(let s=0;s<n;s++)i+=t.children[s].renderNodeCount;return l=l&&!t.collapsed,r=r&&t.visible,0===o.length?{parentNode:t,listIndex:i,revealed:l,visible:r}:this.getParentNodeWithListIndex(o,t.children[n],i+1,l,r)}getNode(e=[]){return this.getTreeNode(e)}getNodeLocation(e){const t=[];let i=e;while(i.parent)t.push(i.parent.children.indexOf(i)),i=i.parent;return t.reverse()}getParentNodeLocation(e){return 0===e.length?void 0:1===e.length?[]:tail2(e)[0]}getFirstElementChild(e){const t=this.getTreeNode(e);if(0!==t.children.length)return t.children[0].element}}