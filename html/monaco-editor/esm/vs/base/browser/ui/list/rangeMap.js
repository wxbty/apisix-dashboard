import{Range}from"../../../common/range.js";export function groupIntersect(t,e){const r=[];for(let n of e){if(t.start>=n.range.end)continue;if(t.end<n.range.start)break;const e=Range.intersect(t,n.range);Range.isEmpty(e)||r.push({range:e,size:n.size})}return r}export function shift({start:t,end:e},r){return{start:t+r,end:e+r}}export function consolidate(t){const e=[];let r=null;for(let n of t){const t=n.range.start,s=n.range.end,i=n.size;r&&i===r.size?r.range.end=s:(r={range:{start:t,end:s},size:i},e.push(r))}return e}function concat(...t){return consolidate(t.reduce(((t,e)=>t.concat(e)),[]))}export class RangeMap{constructor(){this.groups=[],this._size=0}splice(t,e,r=[]){const n=r.length-e,s=groupIntersect({start:0,end:t},this.groups),i=groupIntersect({start:t+e,end:Number.POSITIVE_INFINITY},this.groups).map((t=>({range:shift(t.range,n),size:t.size}))),o=r.map(((e,r)=>({range:{start:t+r,end:t+r+1},size:e.size})));this.groups=concat(s,o,i),this._size=this.groups.reduce(((t,e)=>t+e.size*(e.range.end-e.range.start)),0)}get count(){const t=this.groups.length;return t?this.groups[t-1].range.end:0}get size(){return this._size}indexAt(t){if(t<0)return-1;let e=0,r=0;for(let n of this.groups){const s=n.range.end-n.range.start,i=r+s*n.size;if(t<i)return e+Math.floor((t-r)/n.size);e+=s,r=i}return e}indexAfter(t){return Math.min(this.indexAt(t)+1,this.count)}positionAt(t){if(t<0)return-1;let e=0,r=0;for(let n of this.groups){const s=n.range.end-n.range.start,i=r+s;if(t<i)return e+(t-r)*n.size;e+=s*n.size,r=i}return-1}}